{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Agent Workflow Framework","text":"<p>A sophisticated agent workflow framework built on Microsoft's Agent Framework, offering enterprise-grade orchestration with advanced RAG capabilities and comprehensive tool integration.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Advanced Agent Orchestration: Built on Microsoft's latest Agent Framework</li> <li>Event-Driven Workflow Engine: Sophisticated workflow execution with state management</li> <li>Azure-First Architecture: First-class support for Azure OpenAI</li> <li>Enhanced Tool System: Extensible tool framework with built-in enterprise tools</li> <li>Advanced RAG Integration: Robust knowledge management with hybrid search capabilities</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation &amp; Setup - Get started with the framework</li> <li>Quick Start - Build your first agent in 5 minutes</li> <li>API Reference - Complete API documentation</li> <li>Examples - Real-world usage examples</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Install from Azure Artifacts:</p> <p>```bash pip install agent-workflow-framework ```</p> <p>Create your first agent:</p> <p>```python from agent_workflow_framework import WorkflowEngine, create_assistant</p> <p>engine = WorkflowEngine() agent = create_assistant(\"my_assistant\", description=\"A helpful assistant\") ```</p> <p>Check out the Installation &amp; Setup Guide for detailed instructions.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for the Agent Workflow Framework. This reference covers all core classes, decorators, and methods verified from Microsoft's official documentation.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#chatagent","title":"ChatAgent","text":"<p>The primary agent implementation that uses a chat client to interact with language models.</p>"},{"location":"api/#constructor","title":"Constructor","text":"<pre><code>ChatAgent(\n    chat_client: ChatClientProtocol,\n    instructions: str | None = None,\n    *,\n    id: str | None = None,\n    name: str | None = None,\n    description: str | None = None,\n    chat_message_store_factory: Callable[[], ChatMessageStoreProtocol] | None = None,\n    conversation_id: str | None = None,\n    context_providers: ContextProvider | list[ContextProvider] | None = None,\n    middleware: list[AgentMiddleware | FunctionMiddleware | ChatMiddleware] | None = None,\n    frequency_penalty: float | None = None,\n    logit_bias: dict[str | int, float] | None = None,\n    max_tokens: int | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_id: str | None = None,\n    presence_penalty: float | None = None,\n    response_format: type[BaseModel] | None = None,\n    seed: int | None = None,\n    stop: str | Sequence[str] | None = None,\n    store: bool | None = None,\n    temperature: float | None = None,\n    tool_choice: Literal['auto', 'required', 'none'] | dict[str, Any] | None = 'auto',\n    tools: ToolProtocol | Callable | Sequence[ToolProtocol | Callable] | None = None,\n    top_p: float | None = None,\n    user: str | None = None,\n    additional_chat_options: dict[str, Any] | None = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>chat_client</code> <code>ChatClientProtocol</code> Required. The chat client to use for the agent <code>instructions</code> <code>str \\| None</code> Optional instructions for the agent. These will be added as a system message <code>id</code> <code>str \\| None</code> Unique identifier for the agent. Auto-generated if not provided <code>name</code> <code>str \\| None</code> The name of the agent <code>description</code> <code>str \\| None</code> Brief description of the agent's purpose <code>chat_message_store_factory</code> <code>Callable \\| None</code> Factory function to create a ChatMessageStoreProtocol instance <code>conversation_id</code> <code>str \\| None</code> Conversation ID for service-managed threads <code>context_providers</code> <code>ContextProvider \\| list[ContextProvider] \\| None</code> Context providers for agent invocation <code>middleware</code> <code>list \\| None</code> Middleware to intercept agent and function invocations <code>frequency_penalty</code> <code>float \\| None</code> Penalize frequent tokens (range: -2.0 to 2.0) <code>logit_bias</code> <code>dict[str \\| int, float] \\| None</code> Modify likelihood of specific tokens <code>max_tokens</code> <code>int \\| None</code> Maximum number of tokens to generate <code>metadata</code> <code>dict[str, Any] \\| None</code> Additional metadata for the request <code>model_id</code> <code>str \\| None</code> The model ID to use for the agent <code>presence_penalty</code> <code>float \\| None</code> Penalize tokens based on presence (range: -2.0 to 2.0) <code>response_format</code> <code>type[BaseModel] \\| None</code> Structured output format <code>seed</code> <code>int \\| None</code> Random seed for deterministic responses <code>stop</code> <code>str \\| Sequence[str] \\| None</code> Stop sequences for generation <code>store</code> <code>bool \\| None</code> Whether to store the response <code>temperature</code> <code>float \\| None</code> Sampling temperature (range: 0.0 to 2.0) <code>tool_choice</code> <code>Literal['auto', 'required', 'none'] \\| dict \\| None</code> Tool selection mode. Default: <code>'auto'</code> <code>tools</code> <code>ToolProtocol \\| Callable \\| Sequence \\| None</code> Tools the agent can use <code>top_p</code> <code>float \\| None</code> Nucleus sampling probability <code>user</code> <code>str \\| None</code> User identifier for tracking <code>additional_chat_options</code> <code>dict[str, Any] \\| None</code> Provider-specific parameters <p>Raises:</p> <ul> <li><code>AgentInitializationError</code>: If both <code>conversation_id</code> and <code>chat_message_store_factory</code> are provided</li> </ul> <p>Example:</p> <pre><code>from agent_framework import ChatAgent\nfrom agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\n\nclient = AzureAIAgentClient(\n    async_credential=AzureCliCredential(),\n    endpoint=\"https://your-resource.openai.azure.com/\",\n    deployment_name=\"gpt-4\"\n)\n\nagent = ChatAgent(\n    chat_client=client,\n    name=\"assistant\",\n    description=\"A helpful assistant\",\n    instructions=\"You are a friendly assistant.\",\n    temperature=0.7,\n    max_tokens=500\n)\n</code></pre>"},{"location":"api/#methods","title":"Methods","text":""},{"location":"api/#run","title":"<code>run()</code>","text":"<p>Run the agent with the given messages and options.</p> <pre><code>async def run(\n    messages: str | ChatMessage | list[str] | list[ChatMessage] | None = None,\n    *,\n    thread: AgentThread | None = None,\n    frequency_penalty: float | None = None,\n    logit_bias: dict[str | int, float] | None = None,\n    max_tokens: int | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_id: str | None = None,\n    presence_penalty: float | None = None,\n    response_format: type[BaseModel] | None = None,\n    seed: int | None = None,\n    stop: str | Sequence[str] | None = None,\n    store: bool | None = None,\n    temperature: float | None = None,\n    tool_choice: Literal['auto', 'required', 'none'] | dict[str, Any] | None = None,\n    tools: ToolProtocol | Callable | list[ToolProtocol | Callable] | None = None,\n    top_p: float | None = None,\n    user: str | None = None,\n    additional_chat_options: dict[str, Any] | None = None,\n    **kwargs: Any\n) -&gt; AgentRunResponse\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>messages</code> <code>str \\| ChatMessage \\| list \\| None</code> Messages to process. Can be a string, ChatMessage, or list <code>thread</code> <code>AgentThread \\| None</code> The thread to use for the agent <p>All other parameters override the constructor defaults when provided.</p> <p>Returns:</p> <ul> <li><code>AgentRunResponse</code>: Contains the agent's response with <code>.text</code> property</li> </ul> <p>Example:</p> <pre><code># Simple string input\nresponse = await agent.run(\"Hello, how are you?\")\nprint(response.text)\n\n# With ChatMessage objects\nfrom agent_framework import ChatMessage, ChatRole\nmessage = ChatMessage(ChatRole.User, \"Tell me a joke\")\nresponse = await agent.run(message)\nprint(response.text)\n\n# With thread for conversation history\nthread = agent.get_new_thread()\nresponse1 = await agent.run(\"What is Python?\", thread=thread)\nresponse2 = await agent.run(\"Tell me more\", thread=thread)\n</code></pre>"},{"location":"api/#run_stream","title":"<code>run_stream()</code>","text":"<p>Stream the agent's response with the given messages.</p> <pre><code>def run_stream(\n    messages: str | ChatMessage | list[str] | list[ChatMessage] | None = None,\n    *,\n    thread: AgentThread | None = None,\n    # ... same parameters as run()\n) -&gt; AsyncIterable[AgentRunResponseUpdate]\n</code></pre> <p>Returns:</p> <ul> <li><code>AsyncIterable[AgentRunResponseUpdate]</code>: Async iterator yielding response updates</li> </ul> <p>Example:</p> <pre><code>async for update in agent.run_stream(\"Write a story\"):\n    print(update.text, end=\"\", flush=True)\n</code></pre>"},{"location":"api/#get_new_thread","title":"<code>get_new_thread()</code>","text":"<p>Get a new conversation thread for the agent.</p> <pre><code>def get_new_thread(\n    *,\n    service_thread_id: str | None = None,\n    **kwargs: Any\n) -&gt; AgentThread\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>service_thread_id</code> <code>str \\| None</code> Optional service-managed thread ID <p>Returns:</p> <ul> <li><code>AgentThread</code>: A new thread instance for conversation history</li> </ul> <p>Example:</p> <pre><code>thread = agent.get_new_thread()\nresponse1 = await agent.run(\"Hello\", thread=thread)\nresponse2 = await agent.run(\"How are you?\", thread=thread)\n</code></pre>"},{"location":"api/#as_tool","title":"<code>as_tool()</code>","text":"<p>Convert an agent into a tool that can be used by other agents.</p> <pre><code>def as_tool(\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    arg_name: str = 'task',\n    arg_description: str | None = None,\n    stream_callback: Callable[[AgentRunResponseUpdate], None | Awaitable[None]] | None = None\n) -&gt; AIFunction[BaseModel, str]\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>name</code> <code>str \\| None</code> Tool name. Uses agent's name if None <code>description</code> <code>str \\| None</code> Tool description. Uses agent's description if None <code>arg_name</code> <code>str</code> Name of the function argument. Default: <code>\"task\"</code> <code>arg_description</code> <code>str \\| None</code> Description for the argument <code>stream_callback</code> <code>Callable \\| None</code> Optional callback for streaming responses <p>Returns:</p> <ul> <li><code>AIFunction[BaseModel, str]</code>: A tool that other agents can call</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>: If the agent doesn't implement AgentProtocol</li> <li><code>ValueError</code>: If the agent tool name cannot be determined</li> </ul> <p>Example:</p> <pre><code># Create a research agent\nresearch_agent = ChatAgent(\n    chat_client=client,\n    name=\"research-agent\",\n    description=\"Performs research tasks\"\n)\n\n# Convert to tool\nresearch_tool = research_agent.as_tool()\n\n# Use in another agent\ncoordinator = ChatAgent(\n    chat_client=client,\n    name=\"coordinator\",\n    tools=[research_tool]\n)\n</code></pre>"},{"location":"api/#as_mcp_server","title":"<code>as_mcp_server()</code>","text":"<p>Create an MCP (Model Context Protocol) server from an agent instance.</p> <pre><code>def as_mcp_server(\n    *,\n    server_name: str = 'Agent',\n    version: str | None = None,\n    instructions: str | None = None,\n    lifespan: Callable[[Server], AbstractAsyncContextManager] | None = None,\n    **kwargs: Any\n) -&gt; Server\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>server_name</code> <code>str</code> Name of the MCP server. Default: <code>'Agent'</code> <code>version</code> <code>str \\| None</code> Version of the server <code>instructions</code> <code>str \\| None</code> Instructions for the server <code>lifespan</code> <code>Callable \\| None</code> Lifespan context manager for the server <p>Returns:</p> <ul> <li><code>Server</code>: The MCP server instance</li> </ul>"},{"location":"api/#deserialize_thread","title":"<code>deserialize_thread()</code>","text":"<p>Deserialize a thread from its serialized state.</p> <pre><code>async def deserialize_thread(\n    serialized_thread: Any,\n    **kwargs: Any\n) -&gt; AgentThread\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>serialized_thread</code> <code>Any</code> The serialized thread data <p>Returns:</p> <ul> <li><code>AgentThread</code>: Restored thread instance</li> </ul>"},{"location":"api/#to_dict-to_json","title":"<code>to_dict()</code> / <code>to_json()</code>","text":"<p>Serialize the agent to a dictionary or JSON string.</p> <pre><code>def to_dict(\n    *,\n    exclude: set[str] | None = None,\n    exclude_none: bool = True\n) -&gt; dict[str, Any]\n\ndef to_json(\n    *,\n    exclude: set[str] | None = None,\n    exclude_none: bool = True\n) -&gt; str\n</code></pre>"},{"location":"api/#from_dict-from_json","title":"<code>from_dict()</code> / <code>from_json()</code>","text":"<p>Deserialize an agent from a dictionary or JSON string.</p> <pre><code>@classmethod\ndef from_dict(\n    value: MutableMapping[str, Any],\n    *,\n    dependencies: MutableMapping[str, Any] | None = None\n) -&gt; ChatAgent\n\n@classmethod\ndef from_json(\n    value: str,\n    *,\n    dependencies: MutableMapping[str, Any] | None = None\n) -&gt; ChatAgent\n</code></pre>"},{"location":"api/#attributes","title":"Attributes","text":""},{"location":"api/#display_name","title":"<code>display_name</code>","text":"<p>Returns the display name of the agent (name if present, otherwise id).</p> <pre><code>@property\ndef display_name(self) -&gt; str\n</code></pre>"},{"location":"api/#tools-and-functions","title":"Tools and Functions","text":""},{"location":"api/#ai_function","title":"@ai_function","text":"<p>Decorator that transforms a Python function into an AI-callable tool.</p> <p>Usage:</p> <pre><code>from agent_framework import ai_function\nfrom typing import Annotated\nfrom pydantic import Field\n\n@ai_function\ndef function_name(\n    param: Annotated[type, Field(description=\"Parameter description\")]\n) -&gt; return_type:\n    \"\"\"\n    Function description that the LLM uses to decide when to call this tool.\n    \"\"\"\n    # Implementation\n    return result\n</code></pre> <p>Features:</p> <ul> <li>Automatically generates JSON schema for the LLM</li> <li>Uses function name, docstring, and parameter annotations</li> <li>Validates inputs and outputs</li> <li>Provides error handling context to the LLM</li> </ul> <p>Example:</p> <pre><code>@ai_function\ndef get_weather(\n    location: Annotated[str, Field(description=\"The city name\")],\n    unit: Annotated[str, Field(description=\"Temperature unit\")] = \"celsius\"\n) -&gt; str:\n    \"\"\"Get the weather for a location.\"\"\"\n    return f\"Weather in {location}: 22\u00b0{unit.upper()}\"\n\n# Use in agent\nagent = ChatAgent(\n    chat_client=client,\n    tools=[get_weather]\n)\n</code></pre>"},{"location":"api/#aifunction","title":"AIFunction","text":"<p>A class that wraps a Python function to make it callable by AI models.</p>"},{"location":"api/#constructor_1","title":"Constructor","text":"<pre><code>AIFunction(\n    *,\n    name: str,\n    description: str = '',\n    approval_mode: Literal['always_require', 'never_require'] | None = None,\n    additional_properties: dict[str, Any] | None = None,\n    func: Callable[[...], Awaitable[ReturnT] | ReturnT],\n    input_model: type[ArgsT],\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>name</code> <code>str</code> Required. The name of the function <code>description</code> <code>str</code> Description of the function. Default: <code>\"\"</code> <code>approval_mode</code> <code>Literal['always_require', 'never_require'] \\| None</code> Whether approval is required to run this tool <code>additional_properties</code> <code>dict[str, Any] \\| None</code> Additional properties for the function <code>func</code> <code>Callable</code> Required. The function to wrap <code>input_model</code> <code>type[BaseModel]</code> Required. Pydantic model defining input parameters <p>Example:</p> <pre><code>from pydantic import BaseModel, Field\nfrom agent_framework import AIFunction\n\nclass WeatherArgs(BaseModel):\n    location: Annotated[str, Field(description=\"The city name\")]\n    unit: Annotated[str, Field(description=\"Temperature unit\")] = \"celsius\"\n\nweather_func = AIFunction(\n    name=\"get_weather\",\n    description=\"Get the weather for a location\",\n    func=lambda location, unit=\"celsius\": f\"Weather in {location}: 22\u00b0{unit.upper()}\",\n    approval_mode=\"never_require\",\n    input_model=WeatherArgs\n)\n</code></pre>"},{"location":"api/#methods_1","title":"Methods","text":""},{"location":"api/#invoke","title":"<code>invoke()</code>","text":"<p>Run the AI function with provided arguments.</p> <pre><code>async def invoke(\n    *,\n    arguments: ArgsT | None = None,\n    **kwargs: Any\n) -&gt; ReturnT\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>arguments</code> <code>BaseModel \\| None</code> Pydantic model instance with arguments <code>**kwargs</code> <code>Any</code> Keyword arguments (used if <code>arguments</code> is None) <p>Returns:</p> <ul> <li><code>ReturnT</code>: The result of the function execution</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code>: If arguments is not an instance of the expected input model</li> </ul> <p>Example:</p> <pre><code>result = await weather_func.invoke(\n    arguments=WeatherArgs(location=\"Seattle\", unit=\"fahrenheit\")\n)\n</code></pre>"},{"location":"api/#parameters","title":"<code>parameters()</code>","text":"<p>Get the JSON schema of the function parameters.</p> <pre><code>def parameters() -&gt; dict[str, Any]\n</code></pre> <p>Returns:</p> <ul> <li><code>dict[str, Any]</code>: JSON schema for the function's parameters</li> </ul>"},{"location":"api/#to_json_schema_spec","title":"<code>to_json_schema_spec()</code>","text":"<p>Convert the function to JSON Schema function specification format.</p> <pre><code>def to_json_schema_spec() -&gt; dict[str, Any]\n</code></pre> <p>Returns:</p> <ul> <li><code>dict[str, Any]</code>: Function specification in JSON Schema format</li> </ul>"},{"location":"api/#workflows","title":"Workflows","text":""},{"location":"api/#workflowbuilder","title":"WorkflowBuilder","text":"<p>Creates directed acyclic graphs (DAGs) for multi-agent orchestration.</p> <p>Usage:</p> <pre><code>from agent_framework import WorkflowBuilder, executor\n\nworkflow = (WorkflowBuilder()\n    .add_edge(executor1, executor2)\n    .add_edge(executor2, executor3)\n    .set_start_executor(executor1)\n    .build())\n</code></pre>"},{"location":"api/#methods_2","title":"Methods","text":""},{"location":"api/#add_edge","title":"<code>add_edge()</code>","text":"<p>Define data flow from one executor to another.</p> <pre><code>def add_edge(\n    from_executor: Callable,\n    to_executor: Callable\n) -&gt; WorkflowBuilder\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>from_executor</code> <code>Callable</code> Source executor (output provider) <code>to_executor</code> <code>Callable</code> Target executor (input receiver) <p>Returns:</p> <ul> <li><code>WorkflowBuilder</code>: Self for method chaining</li> </ul> <p>Example:</p> <pre><code>workflow = (WorkflowBuilder()\n    .add_edge(step1, step2)  # step1's output \u2192 step2's input\n    .add_edge(step2, step3)  # step2's output \u2192 step3's input\n)\n</code></pre>"},{"location":"api/#set_start_executor","title":"<code>set_start_executor()</code>","text":"<p>Define the entry point of the workflow.</p> <pre><code>def set_start_executor(\n    executor: Callable\n) -&gt; WorkflowBuilder\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>executor</code> <code>Callable</code> The first executor to run <p>Returns:</p> <ul> <li><code>WorkflowBuilder</code>: Self for method chaining</li> </ul>"},{"location":"api/#build","title":"<code>build()</code>","text":"<p>Compile the workflow into an executable graph.</p> <pre><code>def build() -&gt; Workflow\n</code></pre> <p>Returns:</p> <ul> <li><code>Workflow</code>: Compiled workflow ready to run</li> </ul> <p>Example:</p> <pre><code>workflow = (WorkflowBuilder()\n    .add_edge(step1, step2)\n    .set_start_executor(step1)\n    .build())\n</code></pre>"},{"location":"api/#executor","title":"@executor","text":"<p>Decorator that defines a workflow node (executor).</p> <p>Usage:</p> <pre><code>from agent_framework import executor, WorkflowContext\nfrom typing import Annotated\nfrom pydantic import Field\n\n@executor(id=\"unique_step_id\")\nasync def executor_name(\n    input_param: Annotated[type, Field(description=\"Input description\")]\n) -&gt; output_type:\n    \"\"\"\n    Description of what this executor does.\n    \"\"\"\n    # Call agents, process data\n    result = await some_agent.run(input_param)\n    return result\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>id</code> <code>str</code> Required. Unique identifier for this executor <p>Requirements:</p> <ul> <li>Must be an <code>async</code> function</li> <li>Must use <code>Annotated[type, Field(description=\"...\")]</code> for parameters</li> <li>Return value is passed to the next executor in the workflow</li> </ul> <p>Example:</p> <pre><code>@executor(id=\"research_step\")\nasync def research_executor(\n    topic: Annotated[str, Field(description=\"The topic to research\")]\n) -&gt; dict:\n    \"\"\"Research a topic and gather information.\"\"\"\n    research_notes = await research_agent.run(f\"Research: {topic}\")\n    return {\"topic\": topic, \"notes\": research_notes}\n\n@executor(id=\"writing_step\")\nasync def writing_executor(\n    data: Annotated[dict, Field(description=\"Research data from previous step\")]\n) -&gt; str:\n    \"\"\"Write a blog post from research notes.\"\"\"\n    blog_post = await writer_agent.run(data[\"topic\"], data[\"notes\"])\n    return blog_post\n</code></pre>"},{"location":"api/#workflowcontext","title":"WorkflowContext","text":"<p>Context object for advanced workflow state management.</p> <p>Usage in Executors:</p> <pre><code>@executor(id=\"stateful_step\")\nasync def stateful_executor(\n    input_data: Annotated[str, Field(description=\"Input data\")],\n    ctx: WorkflowContext[str]\n) -&gt; str:\n    \"\"\"Executor with workflow context access.\"\"\"\n\n    # Send messages\n    await ctx.send_message(\"Progress update\")\n\n    # Yield intermediate outputs\n    await ctx.yield_output(\"Intermediate result\")\n\n    # Return final result\n    return \"Final result\"\n</code></pre>"},{"location":"api/#methods_3","title":"Methods","text":""},{"location":"api/#send_message","title":"<code>send_message()</code>","text":"<p>Send a message to other parts of the workflow.</p> <pre><code>async def send_message(message: Any) -&gt; None\n</code></pre>"},{"location":"api/#yield_output","title":"<code>yield_output()</code>","text":"<p>Yield an intermediate output from the workflow.</p> <pre><code>async def yield_output(output: Any) -&gt; None\n</code></pre>"},{"location":"api/#workflow","title":"Workflow","text":"<p>The compiled workflow returned by <code>WorkflowBuilder.build()</code>.</p>"},{"location":"api/#methods_4","title":"Methods","text":""},{"location":"api/#run_1","title":"<code>run()</code>","text":"<p>Execute the workflow with the given input.</p> <pre><code>async def run(input_data: Any) -&gt; Any\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>input_data</code> <code>Any</code> Input for the start executor <p>Returns:</p> <ul> <li><code>Any</code>: The output from the final executor</li> </ul> <p>Example:</p> <pre><code>workflow = (WorkflowBuilder()\n    .add_edge(research_executor, writing_executor)\n    .set_start_executor(research_executor)\n    .build())\n\nresult = await workflow.run(\"AI trends in 2025\")\nprint(result)  # Final blog post\n</code></pre>"},{"location":"api/#azure-integration","title":"Azure Integration","text":""},{"location":"api/#azureaiagentclient","title":"AzureAIAgentClient","text":"<p>Client for Azure AI services with Agent Framework.</p> <p>Constructor:</p> <pre><code>from agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\n\nclient = AzureAIAgentClient(\n    async_credential: AsyncTokenCredential,\n    endpoint: str,\n    deployment_name: str\n)\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>async_credential</code> <code>AsyncTokenCredential</code> Azure credential (e.g., <code>AzureCliCredential()</code>) <code>endpoint</code> <code>str</code> Azure AI project endpoint URL <code>deployment_name</code> <code>str</code> Model deployment name <p>Example:</p> <pre><code>import os\nfrom agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\n\nclient = AzureAIAgentClient(\n    async_credential=AzureCliCredential(),\n    endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n    deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n)\n</code></pre>"},{"location":"api/#azureopenairesponsesclient","title":"AzureOpenAIResponsesClient","text":"<p>Client for Azure OpenAI Responses API.</p> <pre><code>from agent_framework.azure import AzureOpenAIResponsesClient\n\nagent = AzureOpenAIResponsesClient(\n    endpoint: str | None = None,\n    deployment_name: str | None = None,\n    api_version: str | None = None,\n    api_key: str | None = None,\n    credential: AsyncTokenCredential | None = None\n).create_agent(\n    name: str,\n    instructions: str\n)\n</code></pre> <p>Example:</p> <pre><code>from agent_framework.azure import AzureOpenAIResponsesClient\nfrom azure.identity.aio import AzureCliCredential\n\nagent = AzureOpenAIResponsesClient(\n    credential=AzureCliCredential()\n).create_agent(\n    name=\"HaikuBot\",\n    instructions=\"You are an upbeat assistant that writes beautifully.\"\n)\n\nprint(await agent.run(\"Write a haiku about AI.\"))\n</code></pre>"},{"location":"api/#response-objects","title":"Response Objects","text":""},{"location":"api/#agentrunresponse","title":"AgentRunResponse","text":"<p>Response object returned by <code>ChatAgent.run()</code>.</p> <p>Attributes:</p> Attribute Type Description <code>text</code> <code>str</code> The text response from the agent <code>thread_id</code> <code>str \\| None</code> The thread ID if conversation was stored <code>messages</code> <code>list[ChatMessage]</code> All messages in the conversation <p>Example:</p> <pre><code>response = await agent.run(\"Hello!\")\nprint(response.text)\nprint(f\"Thread ID: {response.thread_id}\")\n</code></pre>"},{"location":"api/#agentrunresponseupdate","title":"AgentRunResponseUpdate","text":"<p>Update object yielded by <code>ChatAgent.run_stream()</code>.</p> <p>Attributes:</p> Attribute Type Description <code>text</code> <code>str</code> Incremental text update <code>is_complete</code> <code>bool</code> Whether this is the final update <p>Example:</p> <pre><code>async for update in agent.run_stream(\"Tell me a story\"):\n    print(update.text, end=\"\", flush=True)\n    if update.is_complete:\n        print(\"\\n[Done]\")\n</code></pre>"},{"location":"api/#agentthread","title":"AgentThread","text":"<p>Represents a conversation thread for maintaining history.</p> <p>Creation:</p> <pre><code>thread = agent.get_new_thread()\n</code></pre> <p>Usage:</p> <pre><code># First message\nresponse1 = await agent.run(\"What is Python?\", thread=thread)\n\n# Follow-up message (has context)\nresponse2 = await agent.run(\"Tell me more\", thread=thread)\n</code></pre>"},{"location":"api/#exception-classes","title":"Exception Classes","text":""},{"location":"api/#agentinitializationerror","title":"AgentInitializationError","text":"<p>Raised when there's an error initializing an agent.</p> <p>Common causes:</p> <ul> <li>Both <code>conversation_id</code> and <code>chat_message_store_factory</code> provided</li> <li>Invalid configuration parameters</li> </ul> <p>Example:</p> <pre><code>try:\n    agent = ChatAgent(\n        chat_client=client,\n        conversation_id=\"conv-123\",\n        chat_message_store_factory=my_factory  # \u274c Can't use both\n    )\nexcept AgentInitializationError as e:\n    print(f\"Initialization failed: {e}\")\n</code></pre>"},{"location":"api/#type-aliases-and-enums","title":"Type Aliases and Enums","text":""},{"location":"api/#chatrole","title":"ChatRole","text":"<p>Enum for message roles.</p> <pre><code>from agent_framework import ChatRole\n\nChatRole.User       # User message\nChatRole.Assistant  # Assistant message\nChatRole.System     # System message\nChatRole.Tool       # Tool response message\n</code></pre>"},{"location":"api/#chatmessage","title":"ChatMessage","text":"<p>Represents a chat message.</p> <pre><code>from agent_framework import ChatMessage, ChatRole\n\nmessage = ChatMessage(\n    role: ChatRole,\n    content: str | list[ContentPart]\n)\n</code></pre> <p>Example:</p> <pre><code>user_message = ChatMessage(ChatRole.User, \"Hello!\")\nsystem_message = ChatMessage(ChatRole.System, \"You are a helpful assistant.\")\n</code></pre>"},{"location":"api/#environment-variables","title":"Environment Variables","text":"<p>The framework uses these environment variables for Azure integration:</p> Variable Description Example <code>AZURE_AI_PROJECT_ENDPOINT</code> Azure AI project endpoint URL <code>https://my-project.openai.azure.com/</code> <code>AZURE_AI_MODEL_DEPLOYMENT_NAME</code> Model deployment name <code>gpt-4</code> or <code>gpt-4o-mini</code> <code>AZURE_OPENAI_API_VERSION</code> API version (optional) <code>2024-10-01-preview</code> <code>AZURE_OPENAI_API_KEY</code> API key (if not using Azure CLI auth) <code>your-api-key</code> <p>Setup:</p> <p>Create a <code>.env</code> file:</p> <pre><code>AZURE_AI_PROJECT_ENDPOINT=https://your-resource.openai.azure.com/\nAZURE_AI_MODEL_DEPLOYMENT_NAME=gpt-4\n</code></pre> <p>Load in code:</p> <pre><code>from dotenv import load_dotenv\nload_dotenv()\n</code></pre>"},{"location":"api/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nimport os\nfrom dotenv import load_dotenv\nfrom agent_framework import ChatAgent, ai_function, WorkflowBuilder, executor\nfrom agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\nfrom typing import Annotated\nfrom pydantic import Field\n\n# Load environment\nload_dotenv()\n\n# Define a tool\n@ai_function\ndef get_weather(\n    location: Annotated[str, Field(description=\"City name\")]\n) -&gt; str:\n    \"\"\"Get weather information for a location.\"\"\"\n    return f\"Weather in {location}: Sunny, 72\u00b0F\"\n\n# Create client\nclient = AzureAIAgentClient(\n    async_credential=AzureCliCredential(),\n    endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n    deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n)\n\n# Create agent\nagent = ChatAgent(\n    chat_client=client,\n    name=\"weather-assistant\",\n    instructions=\"You are a helpful weather assistant.\",\n    tools=[get_weather],\n    temperature=0.7\n)\n\n# Define workflow executors\n@executor(id=\"get_weather_info\")\nasync def weather_executor(\n    city: Annotated[str, Field(description=\"City to check\")]\n) -&gt; str:\n    \"\"\"Get weather for a city.\"\"\"\n    response = await agent.run(f\"What's the weather in {city}?\")\n    return response.text\n\n# Build workflow\nworkflow = (WorkflowBuilder()\n    .set_start_executor(weather_executor)\n    .build())\n\n# Run\nasync def main():\n    result = await workflow.run(\"Seattle\")\n    print(result)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"api/#version-information","title":"Version Information","text":"<p>This API reference is based on Microsoft Agent Framework version 1.0.0b251016 (Python).</p> <p>For the latest updates, see the official documentation.</p>"},{"location":"api/#see-also","title":"See Also","text":"<ul> <li>Core Concepts - Framework architecture and design</li> <li>Creating Agents - Agent development guide</li> <li>Working with Tools - Tool creation patterns</li> <li>Building Workflows - Workflow orchestration</li> <li>Examples - Real-world usage examples</li> </ul>"},{"location":"examples-1/","title":"Examples","text":"<p>Complete, production-ready example demonstrating the Agent Workflow Framework capabilities.</p>"},{"location":"examples-1/#overview","title":"Overview","text":"<p>This guide walks through a comprehensive fraud detection system that showcases:</p> <ul> <li>Multi-agent orchestration with specialized roles</li> <li>Custom tool creation and integration</li> <li>Complex workflow state management</li> <li>Real-world data processing patterns</li> <li>Streamlit UI for interactive usage</li> </ul>"},{"location":"examples-1/#prerequisites","title":"Prerequisites","text":"<p>Before running this example, ensure you have:</p> <ul> <li>Framework installed - See Installation Guide</li> <li>Azure OpenAI or OpenAI API access configured</li> <li>Python 3.10 or higher</li> <li>Basic understanding of async Python</li> </ul>"},{"location":"examples-1/#environment-setup","title":"Environment Setup","text":"<p>Create a <code>.env</code> file in the example directory:</p> <pre><code># Azure AI Configuration (recommended)\nAZURE_AI_PROJECT_ENDPOINT=https://your-resource.openai.azure.com/\nAZURE_AI_MODEL_DEPLOYMENT_NAME=gpt-4o-mini\n\n# OR OpenAI Configuration\n# OPENAI_API_KEY=your-api-key-here\n# LLM_MODEL=gpt-4o-mini\n</code></pre>"},{"location":"examples-1/#fraud-detection-workflow","title":"Fraud Detection Workflow","text":"<p>A production-grade multi-agent system for detecting fraudulent transactions through collaborative analysis.</p>"},{"location":"examples-1/#use-case","title":"Use Case","text":"<p>Financial institutions need to analyze transactions for fraud indicators. This system:</p> <ol> <li>Loads transaction data from CSV files</li> <li>Performs initial discrepancy analysis</li> <li>Detects suspicious patterns across transactions</li> <li>Calculates risk scores</li> <li>Makes final fraud determinations</li> <li>Generates detailed audit reports</li> </ol>"},{"location":"examples-1/#real-world-applications","title":"Real-World Applications","text":"<ul> <li>Banking transaction monitoring</li> <li>Insurance claim verification</li> <li>E-commerce fraud prevention</li> <li>Credit card fraud detection</li> <li>Payment processor security</li> </ul>"},{"location":"examples-1/#architecture-overview","title":"Architecture Overview","text":"<p>The system uses five specialized agents working in a coordinated workflow:</p> <pre><code>Data Loading\n     \u2193\nFraud Analyst (Initial Analysis)\n     \u2193\nPattern Detection Agent (Cross-transaction patterns)\n     \u2193\nRisk Scoring Agent (Quantitative assessment)\n     \u2193\nFraud Classifier (Final determination)\n     \u2193\nReport Generator (Audit documentation)\n</code></pre> <p>Each agent focuses on a specific aspect of fraud detection, creating a robust multi-layered analysis system.</p>"},{"location":"examples-1/#project-structure","title":"Project Structure","text":"<pre><code>fraud_detection_workflow/\n\u251c\u2500\u2500 fraud_detection_workflow.py    # Main workflow implementation\n\u251c\u2500\u2500 streamlit_fraud_detection_app.py  # Interactive UI\n\u251c\u2500\u2500 run_streamlit.py               # UI launcher script\n\u251c\u2500\u2500 requirements.txt               # Dependencies\n\u251c\u2500\u2500 .env                          # Configuration\n\u251c\u2500\u2500 sample_source.csv             # Example source data\n\u251c\u2500\u2500 sample_target.csv             # Example target data\n\u2514\u2500\u2500 workflow_data/                # Output directory\n    \u2514\u2500\u2500 reports/                  # Generated reports\n</code></pre>"},{"location":"examples-1/#key-components","title":"Key Components","text":""},{"location":"examples-1/#1-custom-tools","title":"1. Custom Tools","text":"<p>The workflow includes specialized tools for data operations.</p>"},{"location":"examples-1/#2-specialized-agents","title":"2. Specialized Agents","text":"<p>Fraud Analyst Agent - Role: Initial discrepancy identification - Focus: Comparing source vs target data - Output: List of suspicious transactions</p> <p>Pattern Detection Agent - Role: Cross-transaction pattern analysis - Focus: Identifying systematic fraud patterns - Output: Pattern descriptions and affected transactions</p> <p>Risk Scoring Agent - Role: Quantitative risk assessment - Focus: Calculating fraud probability scores (0-100) - Output: Numeric risk scores with justification</p> <p>Fraud Classifier Agent - Role: Final fraud determination - Focus: Binary classification (fraud/legitimate) - Output: Classification with confidence level</p> <p>Report Generator Agent - Role: Audit documentation - Focus: Comprehensive analysis summary - Output: Formatted markdown report</p>"},{"location":"examples-1/#running-the-example","title":"Running the Example","text":""},{"location":"examples-1/#option-1-command-line","title":"Option 1: Command Line","text":"<pre><code># 1. Navigate to example directory\ncd fraud_detection_workflow\n\n# 2. Install dependencies\npip install -r requirements.txt\n\n# 3. Configure environment\ncp .env.example .env\n# Edit .env with your Azure/OpenAI credentials\n\n# 4. Run the workflow\npython fraud_detection_workflow.py\n</code></pre> <p>Output: <pre><code>Starting Fraud Detection Workflow...\nAgent: fraud_analyst - Analyzing discrepancies...\nAgent: pattern_detector - Detecting patterns...\nAgent: risk_scorer - Calculating risk scores...\nAgent: classifier - Making final determination...\nAgent: report_generator - Generating report...\n\nReport saved to: workflow_data/reports/fraud_report_20251103_1230.md\n</code></pre></p>"},{"location":"examples-1/#option-2-streamlit-web-ui","title":"Option 2: Streamlit Web UI","text":"<p>For an interactive, visual experience:</p> <pre><code># Run the Streamlit app\npython run_streamlit.py\n\n# Or directly:\nstreamlit run streamlit_fraud_detection_app.py\n</code></pre> <p>Streamlit UI Features: - Upload custom CSV files - Configure analysis parameters - Real-time workflow execution monitoring - Interactive report viewing - Download generated reports - Visualize transaction analysis</p> <p>UI Components: 1. File Upload Section: Upload source and target CSVs 2. Configuration Panel: Adjust detection thresholds 3. Execution Controls: Start/stop workflow 4. Progress Tracking: Real-time agent status updates 5. Results Display: Interactive report viewing 6. Export Options: Download reports in multiple formats</p>"},{"location":"examples-1/#expected-output","title":"Expected Output","text":"<p>The workflow generates a comprehensive fraud analysis report:</p> <pre><code># Fraud Detection Report\nGenerated: 2025-11-03 12:30:45\n\n## Executive Summary\nAnalyzed 150 transactions\nFound 12 suspicious patterns\nFlagged 8 transactions as fraudulent\n\n## Detailed Findings\n\n### High-Risk Transactions\n- Transaction T001: Risk Score 95/100\n  - Multiple account indicators\n  - Unusual amount pattern\n  - Geographic anomaly\n\n### Detected Patterns\n- Pattern 1: Sequential transactions from same IP\n- Pattern 2: Amount structuring to avoid limits\n\n## Recommendations\n[Action items and next steps]\n</code></pre>"},{"location":"examples-1/#configuration-options","title":"Configuration Options","text":"<p>Environment Variables:</p> <pre><code># Model configuration\nLLM_MODEL=gpt-4o-mini              # Model to use\nTEMPERATURE=0.7                     # Response creativity (0.0-1.0)\nMAX_TOKENS=2000                     # Max response length\n\n# Detection thresholds\nRISK_THRESHOLD=70                   # Score for flagging (0-100)\nPATTERN_CONFIDENCE=0.8              # Pattern detection confidence\n\n# Output configuration\nREPORT_FORMAT=markdown              # Output format (markdown/json)\nSAVE_INTERMEDIATE=true              # Save agent intermediate outputs\n</code></pre> <p>Customization:</p> <p>Modify <code>fraud_detection_workflow.py</code> to adjust: - Agent instructions and behavior - Workflow execution order - State management logic - Tool functionality - Report formatting</p>"},{"location":"examples-1/#key-framework-patterns-demonstrated","title":"Key Framework Patterns Demonstrated","text":"<p>1. Multi-Agent Orchestration - Sequential agent execution - State passing between agents - Specialized agent roles</p> <p>2. Tool Integration - Custom tool creation with <code>@ai_function</code> - Tool parameter validation - Error handling in tools</p> <p>3. State Management - Workflow state initialization - State updates by agents - Final state aggregation</p> <p>4. Error Handling - Graceful failure handling - Retry logic for API calls - Validation of agent outputs</p> <p>5. Production Readiness - Logging and monitoring - Configuration management - Output persistence - Audit trail generation</p>"},{"location":"examples-1/#adapting-this-example","title":"Adapting This Example","text":"<p>Use this fraud detection workflow as a template for:</p> <p>Similar Use Cases: - Content moderation workflows - Data validation pipelines - Multi-stage approval processes - Quality assurance systems - Compliance checking</p> <p>Key Patterns to Reuse: - Multi-agent sequential workflow structure - Specialized agent roles with focused instructions - Custom tool creation for domain-specific operations - State accumulation across workflow stages - Report generation and audit trails</p> <p>Customization Steps: 1. Replace tools with your domain-specific operations 2. Adjust agent instructions for your use case 3. Modify state structure for your data model 4. Update workflow sequence for your process 5. Customize report format for your requirements</p>"},{"location":"examples-1/#additional-resources","title":"Additional Resources","text":""},{"location":"examples-1/#framework-documentation","title":"Framework Documentation","text":"<ul> <li>Core Concepts - Framework architecture</li> <li>Creating Agents - Agent configuration</li> <li>Building Workflows - Workflow patterns</li> <li>Working with Tools - Tool development</li> </ul>"},{"location":"examples-1/#example-code","title":"Example Code","text":"<ul> <li>Full source code: <code>fraud_detection_workflow/</code></li> <li>Sample data: Included CSV files</li> <li>Streamlit UI: <code>streamlit_fraud_detection_app.py</code></li> </ul>"},{"location":"examples-1/#community-examples","title":"Community Examples","text":"<p>Looking for more examples? Contributions welcome!</p> <p>Share your workflow implementations: 1. Fork the repository 2. Add your example with documentation 3. Submit a pull request</p>"},{"location":"examples-1/#getting-help","title":"Getting Help","text":"<p>Questions about this example?</p> <ul> <li>Open an issue on GitHub</li> <li>Check the API Reference</li> <li>Review Quick Start Guide for basics</li> </ul> <p>Ready to build your own workflow? Start with Core Concepts to understand the framework architecture.</p>"},{"location":"examples/","title":"Examples","text":"<p>Practical examples demonstrating how to build production-ready agent workflows using the Agent Workflow Framework.</p>"},{"location":"examples/#overview","title":"Overview","text":"<p>This guide provides complete, working examples that demonstrate:</p> <ul> <li>Real-world use cases for agent workflows</li> <li>Best practices for code organization</li> <li>Tool creation and integration patterns</li> <li>Multi-agent orchestration strategies</li> <li>State management and persistence</li> <li>Error handling and monitoring</li> </ul>"},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<p>Before working with these examples, ensure you have:</p> <ul> <li>Framework installed: See Installation Guide</li> <li>Azure configuration: Environment variables set up</li> <li>Python knowledge: Comfortable with async/await patterns</li> <li>Understanding of core concepts: Reviewed Core Concepts</li> </ul>"},{"location":"examples/#required-environment-variables","title":"Required Environment Variables","text":"<pre><code># Azure AI Configuration (recommended)\nAZURE_AI_PROJECT_ENDPOINT=https://your-resource.openai.azure.com/\nAZURE_AI_MODEL_DEPLOYMENT_NAME=gpt-4o-mini\n\n# OR OpenAI Configuration (alternative)\nOPENAI_API_KEY=your-api-key\nLLM_MODEL=gpt-4o-mini\n</code></pre>"},{"location":"examples/#example-1-fraud-detection-workflow","title":"Example 1: Fraud Detection Workflow","text":"<p>A comprehensive enterprise-grade fraud detection system that compares CSV files, identifies discrepancies, and generates detailed risk assessments.</p>"},{"location":"examples/#use-case","title":"Use Case","text":"<p>Financial institutions and payment processors need to verify transaction integrity by comparing reported transactions against actual records. This workflow automates:</p> <ul> <li>Data comparison: Record-by-record analysis of CSV files</li> <li>Pattern detection: Identification of sophisticated fraud schemes</li> <li>Risk scoring: Quantitative assessment of fraud indicators</li> <li>Alert generation: Automated notifications for high-risk cases</li> <li>Report generation: Comprehensive documentation for investigators</li> </ul>"},{"location":"examples/#real-world-applications","title":"Real-World Applications","text":"<ul> <li>Banking: Verify transaction logs across systems</li> <li>E-commerce: Detect payment fraud and chargebacks</li> <li>Insurance: Identify claims fraud patterns</li> <li>Accounting: Audit financial records for discrepancies</li> <li>Healthcare: Validate billing and claims data</li> </ul>"},{"location":"examples/#architecture-overview","title":"Architecture Overview","text":"<p>The workflow uses a multi-agent pipeline with specialized agents for each analysis stage:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Reported CSV   \u2502     \u2502   Actual CSV    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502  CSV Comparison \u2502 (Tool)\n            \u2502      Tool       \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502 Fraud Analyst   \u2502 (Agent)\n            \u2502   Initial       \u2502\n            \u2502   Analysis      \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502 Pattern         \u2502 (Agent)\n            \u2502   Detector      \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502  Risk Scorer    \u2502 (Agent)\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502    Fraud        \u2502 (Agent)\n            \u2502  Classifier     \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n                  \u2502      \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2510 \u250c\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502  Report   \u2502 \u2502    Alert    \u2502 (Agents)\n         \u2502 Generator \u2502 \u2502  Generator  \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/#key-components","title":"Key Components","text":"<ol> <li>Custom CSV Comparison Tool: Performs detailed file comparison</li> <li>7 Specialized Agents: Each handles specific analysis stages</li> <li>Workflow Engine: Orchestrates execution with state management</li> <li>Monitoring System: Tracks performance and generates alerts</li> <li>Persistence Layer: Saves workflow state and results</li> </ol>"},{"location":"examples/#project-structure","title":"Project Structure","text":"<pre><code>fraud_detection_workflow/\n\u251c\u2500\u2500 fraud_detection_workflow.py    # Main workflow implementation\n\u251c\u2500\u2500 streamlit_fraud_detection_app.py  # Web UI\n\u251c\u2500\u2500 setup_env.py                   # Environment configuration helper\n\u251c\u2500\u2500 run_streamlit.py              # UI launcher script\n\u251c\u2500\u2500 requirements.txt              # Dependencies\n\u251c\u2500\u2500 FRAUD_DETECTION_README.md     # Detailed documentation\n\u251c\u2500\u2500 STREAMLIT_README.md           # UI guide\n\u251c\u2500\u2500 test_data/                    # Generated test CSV files\n\u2514\u2500\u2500 workflow_data/                # Workflow state persistence\n</code></pre>"},{"location":"examples/#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"examples/#1-custom-tool-creation","title":"1. Custom Tool Creation","text":"<p>First, we create a custom tool for CSV comparison:</p> <pre><code>from agent_workflow_framework.tools import BaseTool\nfrom agent_workflow_framework.tools.base import ToolSchema, ToolParameter, ToolResult\nimport pandas as pd\nimport io\n\nclass CSVComparisonTool(BaseTool):\n    \"\"\"Custom tool for comparing two CSV files and identifying discrepancies.\"\"\"\n\n    def __init__(self):\n        super().__init__(name=\"csv_comparator\")\n\n    @property\n    def schema(self) -&gt; ToolSchema:\n        \"\"\"Define the tool's schema for the LLM.\"\"\"\n        return ToolSchema(\n            name=\"csv_comparator\",\n            description=\"Compare two CSV files and identify mismatches, discrepancies, and potential fraud indicators\",\n            parameters=[\n                ToolParameter(\n                    name=\"file1_content\",\n                    type=\"string\",\n                    description=\"Content of the first CSV file (reported/expected data)\",\n                    required=True\n                ),\n                ToolParameter(\n                    name=\"file2_content\",\n                    type=\"string\",\n                    description=\"Content of the second CSV file (actual/received data)\",\n                    required=True\n                ),\n                ToolParameter(\n                    name=\"key_column\",\n                    type=\"string\",\n                    description=\"Primary key column name for matching records\",\n                    required=False,\n                    default=None\n                )\n            ],\n            returns=\"Dictionary containing detailed comparison results\"\n        )\n\n    async def execute(self, file1_content: str, file2_content: str, key_column: str = None) -&gt; ToolResult:\n        \"\"\"\n        Compare two CSV files and return detailed comparison results.\n\n        Returns ToolResult with:\n        - success: bool indicating if comparison succeeded\n        - result: dict with comparison statistics and mismatches\n        - error: str with error message if failed\n        \"\"\"\n        try:\n            # Parse CSV content using pandas\n            df1 = pd.read_csv(io.StringIO(file1_content))\n            df2 = pd.read_csv(io.StringIO(file2_content))\n\n            # Initialize comparison results\n            comparison_results = {\n                \"file1_records\": len(df1),\n                \"file2_records\": len(df2),\n                \"columns_file1\": list(df1.columns),\n                \"columns_file2\": list(df2.columns),\n                \"mismatches\": [],\n                \"missing_in_file2\": [],\n                \"extra_in_file2\": [],\n                \"value_mismatches\": [],\n                \"statistics\": {}\n            }\n\n            # Identify common columns\n            cols1 = set(df1.columns)\n            cols2 = set(df2.columns)\n            common_cols = cols1.intersection(cols2)\n\n            comparison_results[\"column_differences\"] = {\n                \"only_in_file1\": list(cols1 - cols2),\n                \"only_in_file2\": list(cols2 - cols1),\n                \"common_columns\": list(common_cols)\n            }\n\n            # Compare records by key column if specified\n            if key_column and key_column in common_cols:\n                keys1 = set(df1[key_column].astype(str))\n                keys2 = set(df2[key_column].astype(str))\n\n                # Identify missing/extra records\n                comparison_results[\"missing_in_file2\"] = list(keys1 - keys2)\n                comparison_results[\"extra_in_file2\"] = list(keys2 - keys1)\n\n                # Compare matching records\n                common_keys = keys1.intersection(keys2)\n                for key in common_keys:\n                    row1 = df1[df1[key_column].astype(str) == str(key)].iloc[0]\n                    row2 = df2[df2[key_column].astype(str) == str(key)].iloc[0]\n\n                    # Find value mismatches\n                    mismatches = {}\n                    for col in common_cols:\n                        if col != key_column:\n                            val1 = str(row1[col])\n                            val2 = str(row2[col])\n                            if val1 != val2:\n                                mismatches[col] = {\"file1\": val1, \"file2\": val2}\n\n                    if mismatches:\n                        comparison_results[\"value_mismatches\"].append({\n                            \"key\": key,\n                            \"mismatches\": mismatches\n                        })\n\n            # Calculate statistics\n            total_cells = len(common_cols) * min(len(df1), len(df2))\n            mismatched_cells = sum(len(m[\"mismatches\"]) for m in comparison_results[\"value_mismatches\"])\n\n            comparison_results[\"statistics\"] = {\n                \"total_records_compared\": min(len(df1), len(df2)),\n                \"total_mismatches\": len(comparison_results[\"value_mismatches\"]),\n                \"mismatch_percentage\": (len(comparison_results[\"value_mismatches\"]) / min(len(df1), len(df2)) * 100) if min(len(df1), len(df2)) &gt; 0 else 0,\n                \"mismatched_cells\": mismatched_cells,\n                \"cell_mismatch_percentage\": (mismatched_cells / total_cells * 100) if total_cells &gt; 0 else 0\n            }\n\n            return ToolResult(success=True, result=comparison_results)\n\n        except Exception as e:\n            return ToolResult(\n                success=False,\n                error=f\"CSV comparison failed: {str(e)}\",\n                result={\"error\": str(e), \"status\": \"failed\"}\n            )\n</code></pre> <p>Key Points:</p> <ul> <li>BaseTool inheritance: Provides framework integration</li> <li>Schema definition: Tells the LLM what parameters the tool accepts</li> <li>Error handling: Returns ToolResult with success/error information</li> <li>Detailed results: Provides comprehensive comparison data for agents</li> </ul>"},{"location":"examples/#2-creating-specialized-agents","title":"2. Creating Specialized Agents","text":"<p>Each agent has a specific role in the fraud detection pipeline:</p> <pre><code>from agent_workflow_framework import create_specialist, create_assistant\n\n# Fraud Analyst - Initial discrepancy identification\nfraud_analyst = create_specialist(\n    name=\"fraud_analyst\",\n    domain=\"fraud_detection\",\n    expertise_areas=[\"fraud detection\", \"transaction analysis\", \"anomaly detection\"],\n    description=\"Initial fraud analysis specialist\",\n    tools=[\"text_analysis\"],  # Built-in tool\n    system_prompt=\"\"\"You are a senior fraud analyst specializing in transaction fraud detection.\n\nYour expertise includes:\n- Identifying transaction discrepancies and their implications\n- Recognizing common fraud patterns and schemes\n- Analyzing data integrity issues\n- Detecting unauthorized modifications\n- Assessing fraud risk levels\n\nAlways provide specific, detailed analysis with clear fraud indicators and evidence.\"\"\"\n)\n\n# Pattern Detection Agent - Complex pattern recognition\npattern_detector = create_specialist(\n    name=\"pattern_detector\",\n    domain=\"pattern_analysis\",\n    expertise_areas=[\"pattern recognition\", \"behavioral analysis\", \"fraud schemes\"],\n    description=\"Fraud pattern detection specialist\",\n    system_prompt=\"\"\"You are a fraud pattern detection expert specializing in identifying complex fraud schemes.\n\nYour expertise includes:\n- Time-based fraud patterns\n- Amount manipulation patterns\n- Entity relationship patterns\n- Velocity and frequency analysis\n- Modus operandi identification\n\nFocus on identifying sophisticated fraud patterns that might not be immediately obvious.\"\"\"\n)\n\n# Risk Scoring Agent - Quantitative assessment\nrisk_scorer = create_specialist(\n    name=\"risk_scorer\",\n    domain=\"risk_assessment\",\n    expertise_areas=[\"risk assessment\", \"statistical analysis\", \"scoring models\"],\n    description=\"Fraud risk scoring specialist\",\n    system_prompt=\"\"\"You are a risk scoring specialist focused on quantifying fraud risk.\n\nYour responsibilities:\n- Calculate precise risk scores (0-100 scale)\n- Apply weighted scoring methodologies\n- Consider multiple risk factors\n- Provide score breakdowns and justifications\n- Ensure consistent scoring criteria\n\nAlways provide numerical scores with clear explanations of the scoring methodology.\"\"\"\n)\n\n# Fraud Classifier - Final determination\nfraud_classifier = create_specialist(\n    name=\"fraud_classifier\",\n    domain=\"fraud_classification\",\n    expertise_areas=[\"fraud classification\", \"decision making\", \"compliance\"],\n    description=\"Fraud classification and decision specialist\",\n    system_prompt=\"\"\"You are a fraud classification specialist responsible for final fraud determinations.\n\nYour responsibilities:\n- Classify fraud risk levels (HIGH/MEDIUM/LOW)\n- Make clear, actionable recommendations\n- Prioritize investigation efforts\n- Ensure compliance with policies\n- Balance false positives with fraud prevention\n\nProvide clear classifications with specific action items.\"\"\"\n)\n\n# Report Generator - Documentation\nreport_generator = create_assistant(\n    name=\"report_generator\",\n    description=\"Fraud report generation specialist\",\n    system_prompt=\"\"\"You are a fraud reporting specialist who creates comprehensive fraud detection reports.\n\nYour responsibilities:\n- Generate clear, professional fraud reports\n- Include executive summaries and detailed findings\n- Present evidence and risk scores clearly\n- Provide actionable recommendations\n- Ensure reports are suitable for fraud investigators and management\n\nCreate well-structured reports that facilitate quick decision-making.\"\"\"\n)\n</code></pre> <p>Agent Design Principles:</p> <ol> <li>Single Responsibility: Each agent has one clear purpose</li> <li>Domain Expertise: System prompts define specialized knowledge</li> <li>Clear Instructions: Explicit guidance on responsibilities</li> <li>Composition Pattern: Uses framework functions, not inheritance</li> <li>Prompt Engineering: Detailed context for consistent output</li> </ol>"},{"location":"examples/#3-workflow-definition","title":"3. Workflow Definition","text":"<p>Define the workflow nodes with proper dependencies:</p> <pre><code>from agent_workflow_framework import WorkflowDefinition, WorkflowNode, WorkflowVariable, NodeInput\nfrom agent_workflow_framework.workflow.definition import NodeOutput\nfrom agent_workflow_framework.workflow import NodeType, ExecutionStrategy, RetryPolicy\n\nasync def create_fraud_detection_workflow(reported_file: str, actual_file: str) -&gt; WorkflowDefinition:\n    \"\"\"Create a comprehensive fraud detection workflow.\"\"\"\n\n    # Define workflow variables (configuration)\n    variables = [\n        WorkflowVariable(\n            name=\"reported_file\",\n            type=\"string\",\n            default_value=reported_file,\n            description=\"Path to reported transactions CSV\"\n        ),\n        WorkflowVariable(\n            name=\"actual_file\",\n            type=\"string\",\n            default_value=actual_file,\n            description=\"Path to actual transactions CSV\"\n        ),\n        WorkflowVariable(\n            name=\"key_column\",\n            type=\"string\",\n            default_value=\"transaction_id\",\n            description=\"Primary key column for matching records\"\n        ),\n        WorkflowVariable(\n            name=\"fraud_threshold\",\n            type=\"number\",\n            default_value=70,\n            description=\"Fraud risk score threshold (0-100)\"\n        )\n    ]\n\n    # Define workflow nodes (execution steps)\n    nodes = [\n        # Node 1: Read Reported File (Tool execution)\n        WorkflowNode(\n            id=\"read_reported_file\",\n            name=\"Read Reported File\",\n            description=\"Read the reported transactions CSV file\",\n            type=NodeType.TOOL,  # Tool execution node\n            config={\n                \"tool_name\": \"file_read\",  # Built-in tool\n                \"parameter_mapping\": {\n                    \"file_path\": \"file_path\"\n                }\n            },\n            depends_on=[],  # No dependencies - can run first\n            inputs={\n                \"file_path\": NodeInput(variable=\"reported_file\")\n            },\n            outputs=[NodeOutput(name=\"result\", type=\"string\", description=\"Content of reported file\")],\n            timeout_seconds=30\n        ),\n\n        # Node 2: Read Actual File (Parallel with Node 1)\n        WorkflowNode(\n            id=\"read_actual_file\",\n            name=\"Read Actual File\",\n            description=\"Read the actual transactions CSV file\",\n            type=NodeType.TOOL,\n            config={\n                \"tool_name\": \"file_read\",\n                \"parameter_mapping\": {\n                    \"file_path\": \"file_path\"\n                }\n            },\n            depends_on=[],  # No dependencies - can run in parallel\n            inputs={\n                \"file_path\": NodeInput(variable=\"actual_file\")\n            },\n            outputs=[NodeOutput(name=\"result\", type=\"string\", description=\"Content of actual file\")],\n            timeout_seconds=30\n        ),\n\n        # Node 3: CSV Comparison (Depends on Nodes 1 &amp; 2)\n        WorkflowNode(\n            id=\"compare_files\",\n            name=\"CSV Comparison\",\n            description=\"Compare the two CSV files for discrepancies\",\n            type=NodeType.TOOL,\n            config={\n                \"tool_name\": \"csv_comparator\",  # Our custom tool\n                \"parameter_mapping\": {\n                    \"file1_content\": \"reported_content\",\n                    \"file2_content\": \"actual_content\",\n                    \"key_column\": \"key_col\"\n                }\n            },\n            depends_on=[\"read_reported_file\", \"read_actual_file\"],  # Wait for file reads\n            inputs={\n                \"reported_content\": NodeInput(\n                    source_node=\"read_reported_file\",\n                    source_output=\"result\"\n                ),\n                \"actual_content\": NodeInput(\n                    source_node=\"read_actual_file\",\n                    source_output=\"result\"\n                ),\n                \"key_col\": NodeInput(variable=\"key_column\")\n            },\n            outputs=[NodeOutput(name=\"comparison_results\", type=\"dict\")],\n            timeout_seconds=60\n        ),\n\n        # Node 4: Initial Fraud Analysis (Agent execution)\n        WorkflowNode(\n            id=\"initial_analysis\",\n            name=\"Initial Fraud Analysis\",\n            description=\"Analyze comparison results for fraud indicators\",\n            type=NodeType.AGENT,  # Agent execution node\n            config={\n                \"agent_name\": \"fraud_analyst\"  # Use our fraud_analyst agent\n            },\n            depends_on=[\"compare_files\"],\n            inputs={\n                \"message\": NodeInput(\n                    value=\"You are a fraud analyst. Analyze the CSV comparison results provided below for fraud indicators. Provide: 1) Summary of discrepancies, 2) Fraud indicators, 3) Risk assessment, 4) Recommended next steps.\"\n                ),\n                \"comparison_results\": NodeInput(\n                    source_node=\"compare_files\",\n                    source_output=\"result\"\n                )\n            },\n            outputs=[NodeOutput(name=\"fraud_analysis\", type=\"string\")],\n            timeout_seconds=120\n        ),\n\n        # Nodes 5-10: Additional analysis stages\n        # (Pattern Detection, Risk Scoring, Classification, Reporting, Alerts, Action Planning)\n        # ... (see full implementation in fraud_detection_workflow.py)\n    ]\n\n    # Create workflow definition\n    workflow = WorkflowDefinition(\n        name=\"Fraud Detection Analysis\",\n        description=\"Comprehensive fraud detection through CSV comparison and pattern analysis\",\n        version=\"1.0\",\n        variables=variables,\n        nodes=nodes,\n        execution_strategy=ExecutionStrategy.SEQUENTIAL,  # Execute nodes in order\n        max_parallel_nodes=3,  # Allow up to 3 parallel executions\n        global_retry_policy=RetryPolicy(\n            max_attempts=2,\n            delay_seconds=5.0,\n            exponential_backoff=True\n        ),\n        tags=[\"fraud-detection\", \"comparison\", \"risk-analysis\"]\n    )\n\n    return workflow\n</code></pre> <p>Workflow Design Patterns:</p> <ol> <li>Parallel Execution: File reads run simultaneously</li> <li>Sequential Processing: Analysis stages run in order</li> <li>Node Dependencies: <code>depends_on</code> ensures correct execution order</li> <li>Input Mapping: Links outputs to inputs between nodes</li> <li>Type Safety: Output types match input expectations</li> <li>Configuration: Variables allow runtime customization</li> <li>Error Handling: Retry policies for transient failures</li> </ol>"},{"location":"examples/#4-workflow-engine-setup","title":"4. Workflow Engine Setup","text":"<p>Initialize and configure the workflow engine:</p> <pre><code>from agent_workflow_framework import (\n    WorkflowEngine,\n    WorkflowStateManager,\n    FilePersistenceBackend,\n    WorkflowMonitor,\n    console_alert_handler,\n    ToolRegistry\n)\nfrom agent_workflow_framework.tools.builtin import register_builtin_tools\n\nasync def setup_fraud_detection_system():\n    \"\"\"Setup the fraud detection workflow system.\"\"\"\n\n    # 1. Setup Tool Registry\n    tool_registry = ToolRegistry(\"fraud_tools\")\n\n    # Register built-in tools (file operations, text analysis, etc.)\n    categories = register_builtin_tools(tool_registry)\n\n    # Register custom CSV comparison tool\n    csv_tool = CSVComparisonTool()\n    tool_registry.register_tool(csv_tool)\n\n    # 2. Setup Persistence Backend\n    # Saves workflow state to disk for recovery and auditing\n    persistence_backend = FilePersistenceBackend(\"./workflow_data\")\n    state_manager = WorkflowStateManager(\n        backend=persistence_backend,\n        auto_save=True,  # Automatically save state changes\n        checkpoint_interval=30  # Save every 30 seconds\n    )\n\n    # 3. Setup Monitoring\n    # Tracks workflow execution and generates alerts\n    monitor = WorkflowMonitor(retention_hours=24)\n    monitor.add_alert_handler(console_alert_handler)  # Print alerts to console\n\n    # 4. Setup Workflow Engine\n    engine = WorkflowEngine(config={\n        \"max_concurrent_executions\": 3,\n        \"default_timeout\": 300,  # 5 minutes\n        \"enable_persistence\": True\n    })\n\n    # Register all agents with the engine\n    engine.register_agent(fraud_analyst)\n    engine.register_agent(pattern_detector)\n    engine.register_agent(risk_scorer)\n    engine.register_agent(fraud_classifier)\n    engine.register_agent(report_generator)\n    # ... register other agents\n\n    # Register tool registry\n    engine.set_tool_registry(tool_registry)\n\n    # Connect monitoring events\n    engine.on_event(\"workflow_started\", monitor.on_workflow_started)\n    engine.on_event(\"workflow_completed\", monitor.on_workflow_completed)\n    engine.on_event(\"workflow_failed\", monitor.on_workflow_failed)\n    engine.on_event(\"node_started\", monitor.on_node_started)\n    engine.on_event(\"node_completed\", monitor.on_node_completed)\n    engine.on_event(\"node_failed\", monitor.on_node_failed)\n\n    return {\n        \"engine\": engine,\n        \"state_manager\": state_manager,\n        \"monitor\": monitor,\n        \"tool_registry\": tool_registry\n    }\n</code></pre> <p>System Setup Components:</p> <ol> <li>Tool Registry: Manages all available tools</li> <li>Persistence Backend: Saves workflow state for recovery</li> <li>State Manager: Handles checkpointing and state transitions</li> <li>Monitoring: Tracks execution and generates alerts</li> <li>Event Handlers: Connect monitoring to workflow events</li> </ol>"},{"location":"examples/#5-executing-the-workflow","title":"5. Executing the Workflow","text":"<p>Run the fraud detection analysis:</p> <pre><code>async def run_fraud_detection_workflow():\n    \"\"\"Run the fraud detection workflow.\"\"\"\n\n    # 1. Setup system\n    system = await setup_fraud_detection_system()\n    engine = system[\"engine\"]\n    state_manager = system[\"state_manager\"]\n    monitor = system[\"monitor\"]\n\n    # 2. Create workflow\n    workflow = await create_fraud_detection_workflow(\n        reported_file=\"./test_data/reported_transactions.csv\",\n        actual_file=\"./test_data/actual_transactions.csv\"\n    )\n\n    # 3. Validate workflow structure\n    validation_errors = workflow.validate_dependencies()\n    if validation_errors:\n        print(f\"Validation failed: {validation_errors}\")\n        return\n\n    # 4. Save workflow definition\n    await state_manager.save_workflow(workflow)\n\n    # 5. Execute workflow\n    execution = await engine.execute_workflow(\n        workflow=workflow,\n        trigger_data={\n            \"triggered_by\": \"fraud_detection_system\",\n            \"analysis_id\": f\"FRAUD-{datetime.now().strftime('%Y%m%d-%H%M%S')}\",\n            \"timestamp\": datetime.now().isoformat()\n        }\n    )\n\n    # 6. Check results\n    print(f\"Execution Status: {execution.status.value}\")\n    print(f\"Duration: {(execution.completed_at - execution.started_at).total_seconds():.2f}s\")\n\n    # 7. Access node results\n    for node_id, node_exec in execution.node_executions.items():\n        print(f\"{node_id}: {node_exec.status.value}\")\n        if node_exec.output:\n            print(f\"  Output: {str(node_exec.output)[:100]}...\")\n\n    # 8. Save execution results\n    await state_manager.save_execution(execution, immediate=True)\n\n    # 9. Get monitoring statistics\n    stats = monitor.get_workflow_stats()\n    print(f\"Success Rate: {stats['global_stats']['success_rate']:.1%}\")\n\n    return execution\n</code></pre> <p>Execution Flow:</p> <ol> <li>System initialization: Setup engine, monitoring, persistence</li> <li>Workflow creation: Define structure and dependencies</li> <li>Validation: Check for circular dependencies and errors</li> <li>State persistence: Save workflow definition</li> <li>Execution: Run the workflow with trigger data</li> <li>Result retrieval: Access outputs from each node</li> <li>State saving: Persist execution results</li> <li>Monitoring: Review execution statistics</li> </ol>"},{"location":"examples/#running-the-example","title":"Running the Example","text":""},{"location":"examples/#option-1-command-line","title":"Option 1: Command Line","text":"<pre><code># 1. Navigate to example directory\ncd examples/fraud_detection_workflow\n\n# 2. Install dependencies\npip install -r requirements.txt\n\n# 3. Configure environment\npython setup_env.py\n\n# 4. Run the workflow\npython fraud_detection_workflow.py\n</code></pre>"},{"location":"examples/#option-2-streamlit-web-ui","title":"Option 2: Streamlit Web UI","text":"<pre><code># 1. Run the Streamlit launcher\npython run_streamlit.py\n\n# 2. Open browser to http://localhost:8501\n\n# 3. Upload CSV files and configure settings\n\n# 4. Click \"Run Analysis\" to execute workflow\n</code></pre>"},{"location":"examples/#expected-output","title":"Expected Output","text":"<pre><code> FRAUD DETECTION WORKFLOW - CSV COMPARISON &amp; ANALYSIS\n========================================================================\n\n Using Azure AI configuration\n\n Creating test CSV files with fraud indicators...\n   - Reported transactions: ./test_data/reported_transactions.csv\n   - Actual transactions: ./test_data/actual_transactions.csv\n\n1. Setting up tool registry...\n Registered 15 tools including custom CSV comparator\n\n2. Creating fraud detection agents...\n Created 7 specialized fraud detection agents\n\n3. Setting up persistence and monitoring...\n Persistence and monitoring configured\n\n4. Setting up workflow engine...\n Workflow engine configured\n\n Creating fraud detection workflow...\n Fraud detection workflow created: Fraud Detection Analysis\n   - Total nodes: 10\n   - Execution strategy: SEQUENTIAL\n   - Analysis stages: Initial Analysis \u2192 Pattern Detection \u2192 Risk Scoring \u2192 Classification \u2192 Reporting\n\n Executing fraud detection analysis...\n   Analyzing transaction discrepancies...\n   Detecting fraud patterns...\n   Calculating risk scores...\n\n Fraud detection completed!\n   - Execution ID: wf_20250103_143022\n   - Status: completed\n   - Duration: 47.32s\n\n Analysis Stage Results:\n    Compare Files: completed (2.15s)\n    Initial Analysis: completed (12.43s)\n    Pattern Detection: completed (10.28s)\n    Risk Scoring: completed (8.67s)\n    Classify Fraud: completed (7.91s)\n    Generate Report: completed (5.88s)\n\n Fraud Detection Statistics:\n   - System Health: healthy\n   - Total Executions: 1\n   - Success Rate: 100.0%\n   - Average Duration: 47.32s\n\n========================================================================\n FRAUD DETECTION WORKFLOW COMPLETED SUCCESSFULLY!\n========================================================================\n\n Check the generated fraud report for detailed findings and recommendations\n</code></pre>"},{"location":"examples/#key-features-demonstrated","title":"Key Features Demonstrated","text":""},{"location":"examples/#1-custom-tool-integration","title":"1. Custom Tool Integration","text":"<p>The CSV comparison tool shows how to:</p> <ul> <li>Extend <code>BaseTool</code> for custom functionality</li> <li>Define tool schemas for LLM interaction</li> <li>Handle errors gracefully with <code>ToolResult</code></li> <li>Return structured data for agent processing</li> </ul>"},{"location":"examples/#2-multi-agent-orchestration","title":"2. Multi-Agent Orchestration","text":"<p>The workflow demonstrates:</p> <ul> <li>Specialist agents with domain expertise</li> <li>Sequential processing through analysis stages</li> <li>Data flow between agents via node outputs</li> <li>Parallel execution for independent operations</li> </ul>"},{"location":"examples/#3-state-management","title":"3. State Management","text":"<p>The persistence layer provides:</p> <ul> <li>Workflow definitions saved to disk</li> <li>Execution state tracked in real-time</li> <li>Checkpointing for recovery from failures</li> <li>Audit trails for compliance and debugging</li> </ul>"},{"location":"examples/#4-error-handling","title":"4. Error Handling","text":"<p>Robust error management includes:</p> <ul> <li>Retry policies for transient failures</li> <li>Timeout handling for long-running operations</li> <li>Graceful degradation when services fail</li> <li>Detailed error messages for troubleshooting</li> </ul>"},{"location":"examples/#5-monitoring-and-alerts","title":"5. Monitoring and Alerts","text":"<p>The monitoring system tracks:</p> <ul> <li>Execution metrics (duration, success rate)</li> <li>Node-level performance for bottleneck identification</li> <li>Alert generation for high-risk detections</li> <li>Health status of the overall system</li> </ul>"},{"location":"examples/#configuration-options","title":"Configuration Options","text":""},{"location":"examples/#workflow-variables","title":"Workflow Variables","text":"<p>Customize the workflow by modifying variables:</p> <pre><code>variables = [\n    WorkflowVariable(\n        name=\"fraud_threshold\",\n        type=\"number\",\n        default_value=80,  # Increase for stricter detection\n        description=\"Fraud risk score threshold (0-100)\"\n    ),\n    WorkflowVariable(\n        name=\"key_column\",\n        type=\"string\",\n        default_value=\"transaction_id\",  # Change for different key\n        description=\"Primary key column for matching records\"\n    )\n]\n</code></pre>"},{"location":"examples/#agent-customization","title":"Agent Customization","text":"<p>Modify agent system prompts for different domains:</p> <pre><code>fraud_analyst = create_specialist(\n    name=\"fraud_analyst\",\n    domain=\"healthcare_fraud\",  # Domain-specific\n    system_prompt=\"\"\"You are a healthcare fraud analyst specializing in medical billing fraud.\n\nYour expertise includes:\n- Upcoding and unbundling detection\n- Duplicate billing identification\n- Medical necessity validation\n- Provider fraud patterns\n\nAlways cite specific billing codes and regulations.\"\"\"\n)\n</code></pre>"},{"location":"examples/#execution-strategy","title":"Execution Strategy","text":"<p>Adjust workflow execution behavior:</p> <pre><code>workflow = WorkflowDefinition(\n    # ...\n    execution_strategy=ExecutionStrategy.PARALLEL,  # or SEQUENTIAL\n    max_parallel_nodes=5,  # Increase for more concurrency\n    global_retry_policy=RetryPolicy(\n        max_attempts=3,  # More retries for unreliable services\n        delay_seconds=10.0,  # Longer delays\n        exponential_backoff=True\n    )\n)\n</code></pre>"},{"location":"examples/#code-organization-best-practices","title":"Code Organization Best Practices","text":""},{"location":"examples/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<pre><code>fraud_detection/\n\u251c\u2500\u2500 tools/\n\u2502   \u2514\u2500\u2500 csv_tools.py          # Custom tools\n\u251c\u2500\u2500 agents/\n\u2502   \u251c\u2500\u2500 fraud_analyst.py      # Agent definitions\n\u2502   \u251c\u2500\u2500 pattern_detector.py\n\u2502   \u2514\u2500\u2500 risk_scorer.py\n\u251c\u2500\u2500 workflows/\n\u2502   \u2514\u2500\u2500 fraud_workflow.py     # Workflow definitions\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 settings.py           # Configuration\n\u2514\u2500\u2500 main.py                   # Entry point\n</code></pre>"},{"location":"examples/#2-configuration-management","title":"2. Configuration Management","text":"<p>Use environment-based configuration:</p> <pre><code># config/settings.py\nfrom pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings with environment variable support.\"\"\"\n\n    # Azure AI\n    azure_endpoint: str\n    azure_model: str\n\n    # Workflow\n    fraud_threshold: int = 70\n    max_concurrent_executions: int = 3\n    default_timeout: int = 300\n\n    # Persistence\n    workflow_data_dir: str = \"./workflow_data\"\n    auto_save: bool = True\n    checkpoint_interval: int = 30\n\n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n\n# Usage\nsettings = Settings()\n</code></pre>"},{"location":"examples/#3-error-handling-patterns","title":"3. Error Handling Patterns","text":"<p>Centralized error handling:</p> <pre><code># utils/error_handlers.py\nfrom functools import wraps\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef handle_workflow_errors(func):\n    \"\"\"Decorator for workflow error handling.\"\"\"\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        try:\n            return await func(*args, **kwargs)\n        except WorkflowValidationError as e:\n            logger.error(f\"Workflow validation failed: {e}\")\n            raise\n        except WorkflowExecutionError as e:\n            logger.error(f\"Workflow execution failed: {e}\")\n            # Attempt recovery\n            await save_error_state(e)\n            raise\n        except Exception as e:\n            logger.exception(f\"Unexpected error: {e}\")\n            raise\n    return wrapper\n\n@handle_workflow_errors\nasync def run_workflow():\n    # ...\n</code></pre>"},{"location":"examples/#4-testing-strategy","title":"4. Testing Strategy","text":"<p>Comprehensive testing approach:</p> <pre><code># tests/test_fraud_workflow.py\nimport pytest\nfrom unittest.mock import AsyncMock, patch\n\n@pytest.mark.asyncio\nasync def test_csv_comparison_tool():\n    \"\"\"Test CSV comparison with sample data.\"\"\"\n    tool = CSVComparisonTool()\n    result = await tool.execute(\n        file1_content=SAMPLE_CSV_1,\n        file2_content=SAMPLE_CSV_2,\n        key_column=\"transaction_id\"\n    )\n\n    assert result.success is True\n    assert \"value_mismatches\" in result.result\n    assert len(result.result[\"value_mismatches\"]) &gt; 0\n\n@pytest.mark.asyncio\nasync def test_fraud_analyst_agent():\n    \"\"\"Test fraud analyst with mock comparison data.\"\"\"\n    with patch.object(fraud_analyst, '_agent') as mock_agent:\n        mock_agent.run = AsyncMock(return_value=Mock(text=\"Fraud detected\"))\n\n        result = await fraud_analyst.run(MOCK_COMPARISON_DATA)\n\n        assert \"fraud\" in result.lower()\n        mock_agent.run.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_workflow_execution():\n    \"\"\"Test complete workflow with test data.\"\"\"\n    workflow = await create_fraud_detection_workflow(\n        reported_file=\"./test_data/test_reported.csv\",\n        actual_file=\"./test_data/test_actual.csv\"\n    )\n\n    # Validate workflow structure\n    errors = workflow.validate_dependencies()\n    assert len(errors) == 0\n\n    # Execute workflow\n    engine = await setup_test_engine()\n    execution = await engine.execute_workflow(workflow)\n\n    assert execution.status == ExecutionStatus.COMPLETED\n    assert \"generate_report\" in execution.node_executions\n</code></pre>"},{"location":"examples/#deployment-considerations","title":"Deployment Considerations","text":""},{"location":"examples/#production-checklist","title":"Production Checklist","text":"<ul> <li> Security: Implement authentication and authorization</li> <li> Logging: Add comprehensive logging for audit trails</li> <li> Monitoring: Set up alerts for failures and performance issues</li> <li> Persistence: Use database backend instead of file storage</li> <li> Scalability: Configure for horizontal scaling</li> <li> Error Recovery: Implement workflow resume capabilities</li> <li> Testing: Achieve &gt;80% code coverage</li> <li> Documentation: Maintain up-to-date API docs</li> </ul>"},{"location":"examples/#azure-deployment","title":"Azure Deployment","text":"<p>Deploy as Azure Function or Container App:</p> <pre><code># function_app.py (Azure Functions)\nimport azure.functions as func\nfrom fraud_detection_workflow import run_fraud_detection_workflow\n\napp = func.FunctionApp()\n\n@app.route(route=\"detect-fraud\", methods=[\"POST\"])\nasync def detect_fraud(req: func.HttpRequest) -&gt; func.HttpResponse:\n    \"\"\"HTTP trigger for fraud detection workflow.\"\"\"\n\n    # Parse request\n    req_body = req.get_json()\n    reported_file = req_body.get('reported_file')\n    actual_file = req_body.get('actual_file')\n\n    # Execute workflow\n    result = await run_fraud_detection_workflow(reported_file, actual_file)\n\n    # Return results\n    return func.HttpResponse(\n        json.dumps({\n            \"status\": result.status.value,\n            \"execution_id\": result.id,\n            \"summary\": result.outputs.get(\"fraud_report\")\n        }),\n        mimetype=\"application/json\"\n    )\n</code></pre>"},{"location":"examples/#example-2-simple-agent-workflow-coming-soon","title":"Example 2: Simple Agent Workflow (Coming Soon)","text":"<p>A basic single-agent workflow demonstrating core concepts.</p>"},{"location":"examples/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Creating a simple agent with one tool</li> <li>Defining a minimal workflow</li> <li>Running and testing workflows</li> <li>Accessing agent outputs</li> </ul>"},{"location":"examples/#use-case_1","title":"Use Case","text":"<p>Build a weather information agent that: 1. Accepts a city name 2. Calls a weather API 3. Returns formatted weather information</p> <p>Full example coming soon. Check back for updates.</p>"},{"location":"examples/#example-3-multi-agent-collaboration-coming-soon","title":"Example 3: Multi-Agent Collaboration (Coming Soon)","text":"<p>Multiple agents working together on complex tasks.</p>"},{"location":"examples/#what-youll-learn_1","title":"What You'll Learn","text":"<ul> <li>Coordinating multiple specialized agents</li> <li>Passing data between agents</li> <li>Implementing agent handoffs</li> <li>Managing shared state</li> </ul>"},{"location":"examples/#use-case_2","title":"Use Case","text":"<p>Research and content creation pipeline: 1. Research Agent: Gathers information from web 2. Analysis Agent: Extracts key insights 3. Writer Agent: Creates blog post 4. Editor Agent: Reviews and refines content</p> <p>Full example coming soon. Check back for updates.</p>"},{"location":"examples/#example-4-custom-tool-integration-coming-soon","title":"Example 4: Custom Tool Integration (Coming Soon)","text":"<p>Building and integrating custom tools.</p>"},{"location":"examples/#what-youll-learn_2","title":"What You'll Learn","text":"<ul> <li>Creating custom tools with <code>BaseTool</code></li> <li>Defining tool schemas</li> <li>Error handling in tools</li> <li>Testing custom tools</li> </ul>"},{"location":"examples/#use-case_3","title":"Use Case","text":"<p>Database query tool that: 1. Accepts SQL queries 2. Executes against database 3. Returns formatted results 4. Handles connection errors</p> <p>Full example coming soon. Check back for updates.</p>"},{"location":"examples/#additional-resources","title":"Additional Resources","text":""},{"location":"examples/#documentation","title":"Documentation","text":"<ul> <li>Installation Guide - Setup instructions</li> <li>Quick Start - 5-minute introduction</li> <li>Core Concepts - Framework architecture</li> <li>Creating Agents - Agent development</li> <li>Working with Tools - Tool creation</li> <li>Building Workflows - Workflow orchestration</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"examples/#example-code","title":"Example Code","text":"<p>All examples are available in the <code>examples/</code> directory:</p> <pre><code>examples/\n\u251c\u2500\u2500 fraud_detection_workflow/    # Complete fraud detection system\n\u251c\u2500\u2500 simple_agent/               # (Coming soon)\n\u251c\u2500\u2500 multi_agent/                # (Coming soon)\n\u2514\u2500\u2500 custom_tools/               # (Coming soon)\n</code></pre>"},{"location":"examples/#community-examples","title":"Community Examples","text":"<p>Looking for more examples? Check the community contributions:</p> <ul> <li>GitHub Discussions</li> <li>Example Gallery (coming soon)</li> </ul>"},{"location":"examples/#contributing-examples","title":"Contributing Examples","text":"<p>Have a great example to share? We welcome contributions!</p>"},{"location":"examples/#contribution-guidelines","title":"Contribution Guidelines","text":"<ol> <li>Clear use case: Explain the real-world problem solved</li> <li>Complete code: Provide working, tested implementation</li> <li>Documentation: Include setup instructions and explanations</li> <li>Best practices: Follow framework patterns and conventions</li> <li>Testing: Include test cases demonstrating functionality</li> </ol>"},{"location":"examples/#how-to-submit","title":"How to Submit","text":"<ol> <li>Fork the repository</li> <li>Create example in <code>examples/</code> directory</li> <li>Add documentation to this file</li> <li>Submit pull request with description</li> </ol>"},{"location":"examples/#getting-help","title":"Getting Help","text":"<p>Need assistance with these examples?</p> <ul> <li>Documentation: Review the guide section</li> <li>Issues: Report bugs or request features on GitHub Issues</li> <li>Discussions: Ask questions in GitHub Discussions</li> <li>Support: Contact the maintainers for enterprise support</li> </ul> <p>Last Updated: January 2025</p>"},{"location":"installation/","title":"\ud83d\udce6 Installing Python Package via Azure DevOps Artifacts","text":"<p>This guide explains how to securely install the <code>agent_workflow</code> Python package from a private Azure DevOps Artifacts feed using a Personal Access Token (PAT).</p>"},{"location":"installation/#step-1-generate-a-personal-access-token-pat","title":"Step 1: Generate a Personal Access Token (PAT)","text":"<p>The PAT grants read-only access to your package feed.</p> <ol> <li>Navigate to Azure DevOps</li> <li>Click your User Icon (top-right corner)</li> <li>Select Personal access tokens</li> <li>Click New Token</li> <li>Under Scopes, select:</li> <li>Packaging</li> <li>Read</li> <li>Click Create</li> <li>Copy the generated token \u2014 you will not be able to view it again</li> </ol> <p>Treat your PAT like a password. Do not share or store it in source code.  We will refer to it as: <code>&lt;YOUR_PAT_HERE&gt;</code></p>"},{"location":"installation/#step-2-authenticate-pip-netrc-method","title":"Step 2: Authenticate pip (<code>.netrc</code> Method)","text":"<p>This securely stores your PAT so pip can authenticate automatically, without exposing it in your terminal history.</p>"},{"location":"installation/#for-windows-users","title":"\ud83d\udd39 For Windows Users","text":"<pre><code>cd %USERPROFILE%\nnotepad .netrc\n</code></pre> <p>Paste the following into the <code>.netrc</code> file:</p> <pre><code>machine pkgs.dev.azure.com\n    login azure\n    password &lt;YOUR_PAT_HERE&gt;\n</code></pre>"},{"location":"installation/#for-ubuntulinux-users","title":"\ud83d\udd39 For Ubuntu/Linux Users","text":"<pre><code>nano ~/.netrc\n</code></pre> <p>Paste the same content:</p> <pre><code>machine pkgs.dev.azure.com\n    login azure\n    password &lt;YOUR_PAT_HERE&gt;\n</code></pre> <p>Optional but recommended (restricts access):</p> <pre><code>chmod 600 ~/.netrc\n</code></pre>"},{"location":"installation/#step-3-install-the-package","title":"Step 3: Install the Package","text":"<p>Run the following command to install your private package:</p> <pre><code>pip install --index-url \"https://pkgs.dev.azure.com/AIPlanetFramework/agent_framework/_packaging/FEED/pypi/simple/\" --extra-index-url \"https://pypi.org/simple\" agent_workflow\n</code></pre> <ul> <li><code>--index-url</code> \u2192 Your private Azure Artifacts feed </li> <li><code>--extra-index-url</code> \u2192 Public PyPI (fallback for dependencies)</li> </ul>"},{"location":"installation/#benefits-of-this-authentication-method","title":"Benefits of This Authentication Method","text":"Benefit Description No wheel file sharing No manual transfer of <code>.whl</code> files Secure authentication PAT stored in <code>.netrc</code>, not exposed in commands Professional workflow Same as any public pip package installation Zero code changes No storing tokens in scripts or source code"},{"location":"installation/#youre-done","title":"You're done!","text":"<p>You can now install your private package securely just like any public Python package.</p>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get up and running with the Agent Workflow Framework in 5 minutes.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>\u0005 Python 3.10 or higher installed</li> <li>\u0005 Azure OpenAI resource (or OpenAI API key)</li> <li>\u0005 Framework installed - See Installation Guide</li> <li>\u0005 Azure CLI installed (for Azure authentication)</li> </ul>"},{"location":"quickstart/#your-first-agent-in-3-steps","title":"Your First Agent in 3 Steps","text":""},{"location":"quickstart/#step-1-setup-environment","title":"Step 1: Setup Environment","text":"<p>First, authenticate with Azure (if using Azure OpenAI):</p> <pre><code># Login to Azure\naz login\n\n# Set your subscription\naz account set --subscription **your-subscription-id&gt;\n</code></pre> <p>Create a <code>.env</code> file in your project directory:</p> <pre><code># Create .env file\ncat &gt; .env **** 'EOF'\n# Azure AI Configuration (recommended)\nAZURE_AI_PROJECT_ENDPOINT=https://your-resource.openai.azure.com/\nAZURE_AI_MODEL_DEPLOYMENT_NAME=gpt-4o-mini\n\n# OR OpenAI Configuration (alternative)\n# OPENAI_API_KEY=your-api-key-here\n# LLM_MODEL=gpt-4o-mini\nEOF\n</code></pre> <p>Getting Your Azure Values</p> <ol> <li>Go to Azure Portal</li> <li>Navigate to your Azure OpenAI resource</li> <li>Click Keys and Endpoint in the left menu</li> <li>Copy the Endpoint URL</li> <li>Go to Deployments and copy your Deployment name</li> </ol>"},{"location":"quickstart/#step-2-write-your-first-agent","title":"Step 2: Write Your First Agent","text":"<p>Create a file called <code>first_agent.py</code>:</p> <pre><code>import asyncio\nimport os\nfrom dotenv import load_dotenv\nfrom agent_framework import ChatAgent\nfrom agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\n\n# Load environment variables from .env file\nload_dotenv()\n\nasync def main():\n \"\"\"Run your first agent\"\"\"\n\n # 1. Create Azure OpenAI client\n # This automatically uses your Azure CLI credentials\n client = AzureAIAgentClient(\n async_credential=AzureCliCredential(),\n endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n )\n\n # 2. Create an AI agent\n agent = ChatAgent(\n chat_client=client,\n name=\"my-first-agent\",\n instructions=\"You are a helpful assistant that provides concise, clear answers.\",\n temperature=0.7 # Controls randomness (0.0 = focused, 1.0 = creative)\n )\n\n # 3. Run the agent with a query\n print(\"Asking agent: What is Python?\\n\")\n response = await agent.run(\"What is Python?\")\n\n # 4. Display the response\n print(\"Agent Response:\")\n print(\"=\" * 60)\n print(response.text)\n print(\"=\" * 60)\n\nif __name__ == \"__main__\":\n asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#step-3-run-it","title":"Step 3: Run It","text":"<pre><code>python first_agent.py\n</code></pre> <p>Expected Output:</p> <pre><code>Asking agent: What is Python?\n\nAgent Response:\n============================================================\nPython is a high-level, interpreted programming language known\nfor its simplicity and readability. It's widely used for web\ndevelopment, data analysis, automation, artificial intelligence,\nand scientific computing. Python's clean syntax makes it an\nexcellent choice for beginners while being powerful enough for\ncomplex applications.\n============================================================\n</code></pre> <p>** Congratulations! You've just created and run your first AI agent!</p>"},{"location":"quickstart/#what-just-happened","title":"What Just Happened?","text":"<p>Let's break down what your code did:</p> <ol> <li>Created an Azure client - Connects to Azure OpenAI using your credentials</li> <li>Initialized a ChatAgent - The \"brain\" that uses the LLM</li> <li>Sent a message - Your query to the agent</li> <li>Received a response - The agent's AI-generated answer</li> </ol> <pre><code>Your Code ChatAgent Azure OpenAI (LLM) AI Response Your Code\n</code></pre>"},{"location":"quickstart/#next-add-a-tool-to-your-agent","title":"Next: Add a Tool to Your Agent","text":"<p>Let's make your agent more powerful by adding a calculator tool. Tools let agents perform actions beyond text generation.</p>"},{"location":"quickstart/#create-an-agent-with-tools","title":"Create an Agent with Tools","text":"<p>Create <code>agent_with_tools.py</code>:</p> <pre><code>import asyncio\nimport os\nfrom dotenv import load_dotenv\nfrom agent_framework import ChatAgent, ai_function\nfrom agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\nfrom typing import Annotated\nfrom pydantic import Field\n\n# Load environment\nload_dotenv()\n\n# ===== STEP 1: Define a Tool =====\n# The @ai_function decorator turns a Python function into an AI-callable tool\n\n@ai_function\ndef calculator(\n operation: Annotated[str, Field(description=\"The math operation: add, subtract, multiply, or divide\")],\n a: Annotated[float, Field(description=\"First number\")],\n b: Annotated[float, Field(description=\"Second number\")]\n) -&gt; str:\n \"\"\"\n Performs basic mathematical operations.\n Use this tool when the user asks you to calculate or compute mathematical expressions.\n \"\"\"\n operations = {\n \"add\": a + b,\n \"subtract\": a - b,\n \"multiply\": a * b,\n \"divide\": a / b if b != 0 else \"Error: Division by zero\"\n }\n\n result = operations.get(operation, \"Unknown operation\")\n return f\"{a} {operation} {b} = {result}\"\n\nasync def main():\n # Create client\n client = AzureAIAgentClient(\n async_credential=AzureCliCredential(),\n endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n )\n\n # ===== STEP 2: Create Agent with Tool =====\n # Pass the tool to the agent's tools parameter\n agent = ChatAgent(\n chat_client=client,\n name=\"calculator-agent\",\n instructions=\"You are a helpful math assistant. Use the calculator tool for any math operations the user requests.\",\n tools=[calculator], # =H Add the tool here\n temperature=0.7\n )\n\n # ===== STEP 3: Test the Agent =====\n print(\"Asking agent: What is 234 multiplied by 567?\\n\")\n response = await agent.run(\"What is 234 multiplied by 567?\")\n\n print(\"Agent Response:\")\n print(\"=\" * 60)\n print(response.text)\n print(\"=\" * 60)\n\nif __name__ == \"__main__\":\n asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#run-it","title":"Run It","text":"<pre><code>python agent_with_tools.py\n</code></pre> <p>Expected Output:</p> <pre><code>Asking agent: What is 234 multiplied by 567?\n\nAgent Response:\n============================================================\nI'll calculate that for you.\n\n234 multiplied by 567 equals 132,678.\n============================================================\n</code></pre>"},{"location":"quickstart/#what-happened-behind-the-scenes","title":"What Happened Behind the Scenes?","text":"<pre><code>1. User asks: \"What is 234 multiplied by 567?\"\n\n2. Agent decides: \"I need the calculator tool\"\n\n3. Agent calls: calculator(\"multiply\", 234, 567)\n\n4. Tool executes: Returns \"234 multiply 567 = 132678\"\n\n5. Agent responds: Formats the result naturally\n</code></pre> <p>The agent automatically decided to use the tool, called it with the correct parameters, and presented the result in natural language!</p>"},{"location":"quickstart/#understanding-tools","title":"Understanding Tools","text":""},{"location":"quickstart/#anatomy-of-an-ai-function","title":"Anatomy of an AI Function","text":"<pre><code>@ai_function # 1. Decorator makes it AI-callable\ndef tool_name( # 2. Clear, descriptive name\n param: Annotated[type, Field(description=\"What this parameter is\")] # 3. Annotated parameters\n) -&gt; return_type: # 4. Return type\n \"\"\"\n Detailed description of what this tool does. # 5. Docstring (critical!)\n The LLM uses this to decide when to call the tool.\n \"\"\"\n # 6. Implementation\n return result\n</code></pre> <p>Key Points:</p> <ol> <li>Decorator - <code>@ai_function</code> registers it with the framework</li> <li>Function name - Should clearly indicate what it does</li> <li>Annotated parameters - <code>Annotated[type, Field(description=\"...\")]</code> tells the LLM what to pass</li> <li>Return type - Defines what the tool returns</li> <li>Docstring - Most important! The LLM reads this to decide when to use the tool</li> <li>Implementation - Your actual Python logic</li> </ol>"},{"location":"quickstart/#tool-design-best-practices","title":"Tool Design Best Practices","text":"<p>\u0005 Good Tool: <pre><code>@ai_function\ndef get_weather(\n city: Annotated[str, Field(description=\"The city name, e.g., 'London', 'New York'\")]\n) -&gt; str:\n \"\"\"\n Gets current weather information for a specific city.\n Use this when the user asks about weather, temperature, or current conditions.\n Returns temperature and weather description.\n \"\"\"\n # Implementation\n return f\"Weather in {city}: Sunny, 22C\"\n</code></pre></p> <p>L Bad Tool: <pre><code>@ai_function\ndef weather(city: str) -&gt; str:\n \"\"\"Weather.\"\"\"\n return f\"{city}: Sunny\"\n</code></pre></p> <p>Why the first is better: - Clear parameter description with examples - Detailed docstring explaining when to use it - Explicit about what it returns</p>"},{"location":"quickstart/#creating-a-multi-tool-agent","title":"Creating a Multi-Tool Agent","text":"<p>Let's create an agent with multiple tools for different tasks:</p> <pre><code>import asyncio\nimport os\nfrom dotenv import load_dotenv\nfrom agent_framework import ChatAgent, ai_function\nfrom agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\nfrom typing import Annotated\nfrom pydantic import Field\n\nload_dotenv()\n\n# ===== Define Multiple Tools =====\n\n@ai_function\ndef calculator(\n operation: Annotated[str, Field(description=\"Operation: add, subtract, multiply, divide\")],\n a: Annotated[float, Field(description=\"First number\")],\n b: Annotated[float, Field(description=\"Second number\")]\n) -&gt; str:\n \"\"\"Performs mathematical calculations. Use for any math operations.\"\"\"\n operations = {\n \"add\": a + b,\n \"subtract\": a - b,\n \"multiply\": a * b,\n \"divide\": a / b if b != 0 else \"Error: Division by zero\"\n }\n result = operations.get(operation, \"Unknown operation\")\n return f\"{a} {operation} {b} = {result}\"\n\n@ai_function\ndef get_weather(\n city: Annotated[str, Field(description=\"City name\")]\n) -&gt; str:\n \"\"\"\n Gets current weather for a city.\n Use when user asks about weather or temperature.\n \"\"\"\n # Mock weather data - in production, call a real weather API\n weather_data = {\n \"london\": \"Cloudy, 15C\",\n \"new york\": \"Sunny, 22C\",\n \"tokyo\": \"Rainy, 18C\",\n \"paris\": \"Partly cloudy, 17C\"\n }\n\n city_lower = city.lower()\n weather = weather_data.get(city_lower, f\"Weather data not available for {city}\")\n return f\"Current weather in {city}: {weather}\"\n\n@ai_function\ndef convert_currency(\n amount: Annotated[float, Field(description=\"Amount to convert\")],\n from_currency: Annotated[str, Field(description=\"Source currency code (USD, EUR, GBP)\")],\n to_currency: Annotated[str, Field(description=\"Target currency code (USD, EUR, GBP)\")]\n) -&gt; str:\n \"\"\"\n Converts currency amounts between different currencies.\n Use when user asks to convert money or currency.\n \"\"\"\n # Mock exchange rates - in production, call a real currency API\n rates = {\n (\"USD\", \"EUR\"): 0.85,\n (\"USD\", \"GBP\"): 0.73,\n (\"EUR\", \"USD\"): 1.18,\n (\"EUR\", \"GBP\"): 0.86,\n (\"GBP\", \"USD\"): 1.37,\n (\"GBP\", \"EUR\"): 1.16,\n }\n\n if from_currency == to_currency:\n return f\"{amount} {from_currency} = {amount} {to_currency}\"\n\n rate = rates.get((from_currency.upper(), to_currency.upper()))\n if rate is None:\n return f\"Currency conversion not supported for {from_currency} to {to_currency}\"\n\n converted = amount * rate\n return f\"{amount} {from_currency} = {converted:.2f} {to_currency}\"\n\nasync def main():\n # Create client\n client = AzureAIAgentClient(\n async_credential=AzureCliCredential(),\n endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n )\n\n # ===== Create Agent with Multiple Tools =====\n agent = ChatAgent(\n chat_client=client,\n name=\"multi-tool-agent\",\n instructions=\"\"\"You are a helpful assistant with access to several tools:\n\n- calculator: For mathematical operations\n- get_weather: For weather information\n- convert_currency: For currency conversions\n\nUse the appropriate tool based on what the user asks. Be conversational and friendly.\"\"\",\n tools=[calculator, get_weather, convert_currency], # =H All three tools\n temperature=0.7\n )\n\n # ===== Test Different Queries =====\n queries = [\n \"What's the weather in London?\",\n \"Calculate 145 plus 289\",\n \"Convert 100 USD to EUR\"\n ]\n\n for query in queries:\n print(f\"\\nQuery: {query}\")\n print(\"-\" * 60)\n response = await agent.run(query)\n print(f\"Response: {response.text}\\n\")\n\nif __name__ == \"__main__\":\n asyncio.run(main())\n</code></pre> <p>Expected Output:</p> <pre><code>Query: What's the weather in London?\n------------------------------------------------------------\nResponse: The current weather in London is cloudy with a temperature of 15C.\n\nQuery: Calculate 145 plus 289\n------------------------------------------------------------\nResponse: 145 plus 289 equals 434.\n\nQuery: Convert 100 USD to EUR\n------------------------------------------------------------\nResponse: 100 USD is equal to 85.00 EUR.\n</code></pre>"},{"location":"quickstart/#conversation-with-memory","title":"Conversation with Memory","text":"<p>By default, each <code>agent.run()</code> call is independent. To create a conversation with memory, use threads:</p> <pre><code>import asyncio\nimport os\nfrom dotenv import load_dotenv\nfrom agent_framework import ChatAgent\nfrom agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\n\nload_dotenv()\n\nasync def main():\n # Create client\n client = AzureAIAgentClient(\n async_credential=AzureCliCredential(),\n endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n )\n\n # Create agent\n agent = ChatAgent(\n chat_client=client,\n name=\"conversational-agent\",\n instructions=\"You are a friendly assistant. Remember the conversation context.\",\n temperature=0.7\n )\n\n # ===== Create a Thread for Conversation History =====\n thread = agent.get_new_thread()\n\n # ===== Multi-turn Conversation =====\n print(\"Starting conversation...\\n\")\n\n # Turn 1\n response1 = await agent.run(\"My name is Alice\", thread=thread)\n print(f\"User: My name is Alice\")\n print(f\"Agent: {response1.text}\\n\")\n\n # Turn 2 - Agent remembers Alice from previous message\n response2 = await agent.run(\"What's my name?\", thread=thread)\n print(f\"User: What's my name?\")\n print(f\"Agent: {response2.text}\\n\")\n\n # Turn 3\n response3 = await agent.run(\"What did I tell you in my first message?\", thread=thread)\n print(f\"User: What did I tell you in my first message?\")\n print(f\"Agent: {response3.text}\\n\")\n\nif __name__ == \"__main__\":\n asyncio.run(main())\n</code></pre> <p>Expected Output:</p> <pre><code>Starting conversation...\n\nUser: My name is Alice\nAgent: Nice to meet you, Alice! How can I help you today?\n\nUser: What's my name?\nAgent: Your name is Alice.\n\nUser: What did I tell you in my first message?\nAgent: In your first message, you told me that your name is Alice.\n</code></pre> <p>Key Points:</p> <ul> <li>Thread = Conversation history storage</li> <li>Without thread: Each message is independent (agent has no memory)</li> <li>With thread: Agent remembers previous messages in the conversation</li> </ul>"},{"location":"quickstart/#streaming-responses","title":"Streaming Responses","text":"<p>For long responses, use streaming to display text as it's generated:</p> <pre><code>import asyncio\nimport os\nfrom dotenv import load_dotenv\nfrom agent_framework import ChatAgent\nfrom agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\n\nload_dotenv()\n\nasync def main():\n # Create client\n client = AzureAIAgentClient(\n async_credential=AzureCliCredential(),\n endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n )\n\n # Create agent\n agent = ChatAgent(\n chat_client=client,\n name=\"streaming-agent\",\n instructions=\"You are a helpful assistant.\",\n temperature=0.7\n )\n\n # ===== Stream the Response =====\n print(\"Question: Write a short story about a robot.\\n\")\n print(\"Agent Response (streaming):\")\n print(\"-\" * 60)\n\n async for update in agent.run_stream(\"Write a short story about a robot.\"):\n # Print each chunk as it arrives\n print(update.text, end=\"\", flush=True)\n\n print(\"\\n\" + \"-\" * 60)\n\nif __name__ == \"__main__\":\n asyncio.run(main())\n</code></pre> <p>Output:</p> <pre><code>Question: Write a short story about a robot.\n\nAgent Response (streaming):\n------------------------------------------------------------\nIn a small workshop, a robot named Circuit came to life.\nUnlike other robots, Circuit had a peculiar fascination\nwith flowers. Each morning, it would water the garden,\ncarefully examining each petal and leaf...\n------------------------------------------------------------\n</code></pre> <p>The text appears word by word as the LLM generates it, instead of waiting for the complete response.</p>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quickstart/#issue-azureclicredential-authentication-failed","title":"Issue: \"AzureCliCredential authentication failed\"","text":"<p>Cause: Not logged into Azure CLI</p> <p>Solution: <pre><code># Login to Azure\naz login\n\n# Verify login\naz account show\n\n# Set subscription\naz account set --subscription **your-subscription-id&gt;\n</code></pre></p>"},{"location":"quickstart/#issue-environment-variable-azure_ai_project_endpoint-not-found","title":"Issue: \"Environment variable AZURE_AI_PROJECT_ENDPOINT not found\"","text":"<p>Cause: Missing or incorrect <code>.env</code> file</p> <p>Solution:</p> <ol> <li> <p>Verify <code>.env</code> file exists in your project directory: <pre><code>ls -la .env\n</code></pre></p> </li> <li> <p>Check contents: <pre><code>cat .env\n</code></pre></p> </li> <li> <p>Ensure it has the correct values: <pre><code>AZURE_AI_PROJECT_ENDPOINT=https://your-resource.openai.azure.com/\nAZURE_AI_MODEL_DEPLOYMENT_NAME=gpt-4o-mini\n</code></pre></p> </li> <li> <p>Make sure <code>load_dotenv()</code> is called in your code: <pre><code>from dotenv import load_dotenv\nload_dotenv() # =H Must be called before accessing os.getenv()\n</code></pre></p> </li> </ol>"},{"location":"quickstart/#issue-agent-doesnt-use-the-tool","title":"Issue: \"Agent doesn't use the tool\"","text":"<p>Cause: Tool description not clear enough for the LLM</p> <p>Solutions:</p> <ol> <li>Make the docstring more explicit:</li> </ol> <p>L Bad: <pre><code>@ai_function\ndef search(query: str) -&gt; str:\n \"\"\"Search.\"\"\"\n pass\n</code></pre></p> <p>\u0005 Good: <pre><code>@ai_function\ndef web_search(\n query: Annotated[str, Field(description=\"Precise search query with keywords\")]\n) -&gt; str:\n \"\"\"\n Searches the web using Google and returns top results.\n Use this tool when the user asks for current information, facts, or\n needs to find something online.\n \"\"\"\n pass\n</code></pre></p> <ol> <li> <p>Mention tools in agent instructions: <pre><code>agent = ChatAgent(\n chat_client=client,\n instructions=\"You are a helpful assistant. When users ask about weather, use the get_weather tool.\", # =H Explicit\n tools=[get_weather]\n)\n</code></pre></p> </li> <li> <p>Use specific parameter descriptions: <pre><code>@ai_function\ndef calculator(\n operation: Annotated[str, Field(description=\"Must be one of: add, subtract, multiply, divide\")], # =H Very specific\n a: Annotated[float, Field(description=\"The first number in the calculation\")],\n b: Annotated[float, Field(description=\"The second number in the calculation\")]\n) -&gt; str:\n \"\"\"Performs mathematical calculations.\"\"\"\n pass\n</code></pre></p> </li> </ol>"},{"location":"quickstart/#issue-modulenotfounderror-no-module-named-agent_framework","title":"Issue: \"ModuleNotFoundError: No module named 'agent_framework'\"","text":"<p>Cause: Framework not installed or wrong Python environment</p> <p>Solution:</p> <ol> <li> <p>Verify installation: <pre><code>python -c \"import agent_framework; print(agent_framework.__version__)\"\n</code></pre></p> </li> <li> <p>If not installed, follow Installation Guide</p> </li> <li> <p>Check you're using the correct Python: <pre><code>which python\npython --version\n</code></pre></p> </li> <li> <p>Reinstall if needed: <pre><code>pip install --index-url \"https://pkgs.dev.azure.com/...\" agent_workflow\n</code></pre></p> </li> </ol>"},{"location":"quickstart/#issue-the-agent-takes-too-long-to-respond","title":"Issue: \"The agent takes too long to respond\"","text":"<p>Cause: Large model or complex query</p> <p>Solutions:</p> <ol> <li> <p>Use a faster model: <pre><code># Instead of gpt-4\ndeployment_name=\"gpt-4o-mini\" # Faster and cheaper\n</code></pre></p> </li> <li> <p>Reduce temperature for more focused responses: <pre><code>agent = ChatAgent(\n chat_client=client,\n temperature=0.3, # Lower = faster, more focused\n max_tokens=500 # Limit response length\n)\n</code></pre></p> </li> <li> <p>Use streaming for better UX: <pre><code>async for update in agent.run_stream(query):\n print(update.text, end=\"\", flush=True)\n</code></pre></p> </li> </ol>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've built your first agents and tools, explore more:</p>"},{"location":"quickstart/#learn-core-concepts","title":"= Learn Core Concepts","text":"<ul> <li>Core Concepts - Understand the framework architecture</li> <li>Working with Tools - Create more sophisticated tools</li> <li>Creating Agents - Build specialized agents</li> <li>Building Workflows - Orchestrate multiple agents</li> </ul>"},{"location":"quickstart/#see-real-examples","title":"** See Real Examples","text":"<ul> <li>Examples - Complete, production-ready examples</li> <li>Fraud Detection Workflow (comprehensive multi-agent system)</li> <li>Simple agent patterns</li> <li>Multi-agent collaboration</li> </ul>"},{"location":"quickstart/#reference-documentation","title":"= Reference Documentation","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Installation Guide - Detailed setup instructions</li> </ul>"},{"location":"quickstart/#build-something","title":"= Build Something","text":"<p>Try these progressive challenges:</p> <ol> <li>Beginner: Create a weather agent that answers questions about multiple cities</li> <li>Intermediate: Build a research agent that searches the web and summarizes findings</li> <li>Advanced: Create a multi-agent workflow with specialist agents for different tasks</li> </ol>"},{"location":"quickstart/#example-projects-to-try","title":"Example Projects to Try","text":""},{"location":"quickstart/#1-personal-assistant-agent","title":"1. Personal Assistant Agent","text":"<p>Create an agent that can: - Check weather - Set reminders (save to file) - Perform calculations - Answer general questions</p>"},{"location":"quickstart/#2-code-helper-agent","title":"2. Code Helper Agent","text":"<p>Build an agent with tools to: - Search Python documentation - Explain code snippets - Suggest fixes for common errors</p>"},{"location":"quickstart/#3-data-analysis-agent","title":"3. Data Analysis Agent","text":"<p>Create an agent that can: - Read CSV files - Calculate statistics - Generate summary reports - Create visualizations</p>"},{"location":"quickstart/#get-help","title":"Get Help","text":"<p>Need assistance?</p> <ul> <li>= GitHub Discussions - Ask questions</li> <li>=\u001b Report Issues - Found a bug?</li> <li>= Full Documentation - Comprehensive guides</li> <li>** Examples - Learn from complete examples</li> </ul>"},{"location":"quickstart/#quick-reference","title":"Quick Reference","text":""},{"location":"quickstart/#essential-code-patterns","title":"Essential Code Patterns","text":"<p>Create an agent: <pre><code>agent = ChatAgent(\n chat_client=client,\n name=\"agent-name\",\n instructions=\"Agent purpose and behavior\",\n tools=[tool1, tool2], # Optional\n temperature=0.7\n)\n</code></pre></p> <p>Run an agent: <pre><code>response = await agent.run(\"Your query\")\nprint(response.text)\n</code></pre></p> <p>Create a tool: <pre><code>@ai_function\ndef tool_name(\n param: Annotated[type, Field(description=\"Description\")]\n) -&gt; return_type:\n \"\"\"What this tool does.\"\"\"\n return result\n</code></pre></p> <p>Conversation with memory: <pre><code>thread = agent.get_new_thread()\nresponse1 = await agent.run(\"First message\", thread=thread)\nresponse2 = await agent.run(\"Second message\", thread=thread)\n</code></pre></p> <p>Stream responses: <pre><code>async for update in agent.run_stream(\"Long query\"):\n print(update.text, end=\"\", flush=True)\n</code></pre></p> <p>Ready to build? Start with the Core Concepts to understand the framework architecture!</p>"},{"location":"guide/agents/","title":"Creating Agents","text":"<p>Agents are specialized AI components that use tools to accomplish tasks. This framework uses a composition pattern to make agents flexible, testable, and maintainable.</p>"},{"location":"guide/agents/#understanding-the-composition-pattern","title":"Understanding the Composition Pattern","text":""},{"location":"guide/agents/#traditional-inheritance-not-used-here","title":"Traditional Inheritance (Not Used Here)","text":"<pre><code># \u274c NOT how this framework works\nclass MyAgent(BaseAgent):  # Inheriting from framework\n    def __init__(self):\n        super().__init__()\n</code></pre>"},{"location":"guide/agents/#composition-pattern-framework-approach","title":"Composition Pattern (Framework Approach)","text":"<pre><code># \u2705 How this framework works\nclass MyAgent:  # Regular Python class\n    def __init__(self):\n        self._agent = ChatAgent(...)  # HAS-A ChatAgent\n</code></pre> <p>Benefits: - Your agent class is just a container for logic - No framework coupling in your business code - Easy to test and mock - Clear separation of concerns</p>"},{"location":"guide/agents/#creating-your-first-agent","title":"Creating Your First Agent","text":""},{"location":"guide/agents/#basic-structure","title":"Basic Structure","text":"<p>Every agent follows this pattern:</p> <pre><code>from agent_framework import ChatAgent\nfrom agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\nimport os\n\nclass MyAgent:\n    def __init__(self):\n        self.name = \"MyAgent\"\n\n        # 1. Define instructions (the agent's \"personality\")\n        instructions = \"\"\"Clear instructions for the agent.\"\"\"\n\n        # 2. Define tools the agent can use\n        self.tools = [tool1, tool2]\n\n        # 3. Set up Azure AI client\n        self.client = AzureAIAgentClient(\n            async_credential=AzureCliCredential(),\n            endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n            deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n        )\n\n        # 4. Compose the internal ChatAgent\n        self._agent = ChatAgent(\n            chat_client=self.client,\n            instructions=instructions,\n            tools=self.tools\n        )\n\n    async def run(self, query: str) -&gt; str:\n        \"\"\"Public interface for running the agent.\"\"\"\n        response = await self._agent.run(query)\n        return response.text\n</code></pre>"},{"location":"guide/agents/#complete-example-research-agent","title":"Complete Example: Research Agent","text":"<p>Create a file <code>agents.py</code>:</p> <pre><code>from agent_framework import ChatAgent\nfrom agent_framework.azure import AzureAIAgentClient\nfrom azure.identity.aio import AzureCliCredential\nimport os\n\n# Import the tools we defined earlier\nfrom src.agent_workflow_framework.tools.web_tools import web_search, read_url\n\nclass ResearchAgent:\n    \"\"\"\n    A specialized agent for performing web research and summarizing content.\n    Its public interface is a single `run` method.\n    \"\"\"\n\n    def __init__(self):\n        self.name = \"ResearchAgent\"\n\n        # 1. Define the agent's \"personality\" and purpose.\n        # This is a critical piece of prompt engineering.\n        instructions = \"\"\"You are a world-class research assistant. \n        Your job is to find information using the 'web_search' tool and then \n        read promising URLs using the 'read_url' tool.\n\n        Your research process:\n        1. Use web_search to find relevant sources\n        2. Use read_url to read the most promising URLs\n        3. Synthesize the information into a clear, concise summary\n\n        You must be concise and factual. Do not make up information.\n        If you cannot find an answer, state that clearly.\n        Always cite your sources by mentioning the URLs you read.\"\"\"\n\n        # 2. Define the list of tool functions this agent can use\n        self.tools = [web_search, read_url]\n\n        # 3. Set up the LLM client\n        # AzureCliCredential() automatically and securely finds your\n        # logged-in Azure credentials.\n        # AzureAIAgentClient reads endpoint/deployment from .env variables.\n        self.client = AzureAIAgentClient(\n            async_credential=AzureCliCredential(),\n            endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n            deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n        )\n\n        # 4. Compose the internal ChatAgent\n        # This is the \"brain\" of our agent. We pass it the client,\n        # our instructions, and the tools it's allowed to use.\n        self._agent = ChatAgent(\n            chat_client=self.client,\n            instructions=instructions,\n            tools=self.tools\n        )\n\n    async def run(self, query: str) -&gt; str:\n        \"\"\"\n        Runs the agent with a specific query. This is the single, \n        clean entry point for our agent.\n        \"\"\"\n        print(f\"\\n--- [{self.name}] Received query: {query} ---\")\n\n        # 5. Delegate the work to the internal ChatAgent\n        # The .run() method handles the entire conversation loop:\n        # -&gt; sending the query,\n        # -&gt; deciding to call a tool,\n        # -&gt; executing the tool,\n        # -&gt; sending the tool's result back,\n        # -&gt; and generating a final text response.\n        response = await self._agent.run(query)\n\n        print(f\"--- [{self.name}] Responding ---\")\n        return response.text\n</code></pre>"},{"location":"guide/agents/#key-components-explained","title":"Key Components Explained","text":""},{"location":"guide/agents/#1-instructions-prompt-engineering","title":"1. Instructions (Prompt Engineering)","text":"<p>The <code>instructions</code> parameter is the most critical part of your agent. It defines:</p> <ul> <li>Role: What is the agent's expertise?</li> <li>Capabilities: What tools can it use?</li> <li>Process: How should it approach tasks?</li> <li>Constraints: What should it avoid?</li> <li>Output format: How should it respond?</li> </ul>"},{"location":"guide/agents/#example-structured-instructions","title":"Example: Structured Instructions","text":"<pre><code>instructions = \"\"\"You are a professional data analyst specializing in financial reports.\n\n**Capabilities:**\n- Analyze CSV files using the analyze_csv tool\n- Calculate statistics using built-in Python functions\n- Generate insights from numerical data\n\n**Process:**\n1. Load the data using the provided file path\n2. Perform statistical analysis\n3. Identify key trends and anomalies\n4. Present findings in a clear, bullet-point format\n\n**Constraints:**\n- Never make up data or statistics\n- Always cite the source file in your analysis\n- If data is incomplete, clearly state the limitations\n\n**Output Format:**\n- Start with a brief summary (2-3 sentences)\n- List key findings as bullet points\n- End with actionable recommendations\"\"\"\n</code></pre>"},{"location":"guide/agents/#2-tools-selection","title":"2. Tools Selection","text":"<p>Choose tools that match your agent's purpose:</p> <pre><code># Research agent: web tools\nself.tools = [web_search, read_url]\n\n# Data agent: file and analysis tools\nself.tools = [read_file, analyze_csv, write_report]\n\n# General assistant: no tools (pure LLM reasoning)\nself.tools = []\n</code></pre>"},{"location":"guide/agents/#3-azure-client-setup","title":"3. Azure Client Setup","text":"<p>The client handles authentication and API calls:</p> <pre><code>from azure.identity.aio import AzureCliCredential\nfrom agent_framework.azure import AzureAIAgentClient\n\n# Automatically uses your `az login` credentials\nclient = AzureAIAgentClient(\n    async_credential=AzureCliCredential(),\n    endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n    deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n)\n</code></pre> <p>Environment variables required: <pre><code>AZURE_AI_PROJECT_ENDPOINT=https://your-project.openai.azure.com/\nAZURE_AI_MODEL_DEPLOYMENT_NAME=gpt-4\n</code></pre></p>"},{"location":"guide/agents/#4-the-run-method","title":"4. The <code>run()</code> Method","text":"<p>Your agent's public interface should be clean and simple:</p> <pre><code>async def run(self, query: str) -&gt; str:\n    \"\"\"\n    Processes a user query and returns the agent's response.\n\n    Args:\n        query: The user's input or question\n\n    Returns:\n        The agent's text response after using tools and reasoning\n    \"\"\"\n    response = await self._agent.run(query)\n    return response.text\n</code></pre>"},{"location":"guide/agents/#creating-specialized-agents","title":"Creating Specialized Agents","text":""},{"location":"guide/agents/#example-writer-agent-no-tools","title":"Example: Writer Agent (No Tools)","text":"<p>Some agents don't need tools\u2014they use pure LLM reasoning:</p> <pre><code>class WriterAgent:\n    \"\"\"\n    A specialized agent for writing high-quality blog posts.\n    No tools needed\u2014uses LLM reasoning and generation only.\n    \"\"\"\n    def __init__(self):\n        self.name = \"WriterAgent\"\n\n        instructions = \"\"\"You are a professional blog post writer with expertise \n        in technical content.\n\n        When given a topic and research notes:\n        1. Analyze the key points from the research\n        2. Structure a compelling narrative\n        3. Write a 3-paragraph blog post using Markdown formatting\n        4. Use engaging language while staying factual\n        5. Include a catchy opening and strong conclusion\n\n        Output Format:\n        - Use ## for the title\n        - Use **bold** for key terms\n        - Keep paragraphs concise (3-4 sentences each)\"\"\"\n\n        self.client = AzureAIAgentClient(\n            async_credential=AzureCliCredential(),\n            endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n            deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n        )\n\n        # No tools needed\u2014pure LLM generation\n        self._agent = ChatAgent(\n            chat_client=self.client,\n            instructions=instructions,\n            tools=[]\n        )\n\n    async def run(self, topic: str, research_notes: str) -&gt; str:\n        \"\"\"\n        Generates a blog post from a topic and research notes.\n        \"\"\"\n        prompt = f\"\"\"Topic: {topic}\n\nResearch Notes:\n{research_notes}\n\nWrite the blog post:\"\"\"\n\n        print(f\"\\n--- [{self.name}] Received prompt ---\")\n        response = await self._agent.run(prompt)\n        print(f\"--- [{self.name}] Responding ---\")\n\n        return response.text\n</code></pre>"},{"location":"guide/agents/#example-data-analyst-agent","title":"Example: Data Analyst Agent","text":"<pre><code>from src.agent_workflow_framework.tools.data_tools import read_file, analyze_csv, write_file\n\nclass DataAnalystAgent:\n    \"\"\"Agent specialized in analyzing CSV data and generating reports.\"\"\"\n\n    def __init__(self):\n        self.name = \"DataAnalystAgent\"\n\n        instructions = \"\"\"You are a data analyst specializing in CSV analysis.\n\n        **Process:**\n        1. Read the CSV file using read_file tool\n        2. Analyze it using analyze_csv tool\n        3. Generate insights about trends, averages, and anomalies\n        4. Write a report using write_file tool\n\n        Always include:\n        - Summary statistics\n        - Key trends\n        - Notable outliers\n        - Actionable recommendations\"\"\"\n\n        self.tools = [read_file, analyze_csv, write_file]\n\n        self.client = AzureAIAgentClient(\n            async_credential=AzureCliCredential(),\n            endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n            deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n        )\n\n        self._agent = ChatAgent(\n            chat_client=self.client,\n            instructions=instructions,\n            tools=self.tools\n        )\n\n    async def run(self, csv_path: str) -&gt; str:\n        query = f\"Analyze the CSV file at {csv_path} and generate a report.\"\n        response = await self._agent.run(query)\n        return response.text\n</code></pre>"},{"location":"guide/agents/#testing-your-agent","title":"Testing Your Agent","text":""},{"location":"guide/agents/#simple-test-script","title":"Simple Test Script","text":"<pre><code>import asyncio\nimport os\nfrom dotenv import load_dotenv\nfrom agents import ResearchAgent\n\nasync def test_research_agent():\n    load_dotenv()\n\n    agent = ResearchAgent()\n    result = await agent.run(\"What is the Agent Framework by Microsoft?\")\n\n    print(\"\\n=== Agent Response ===\")\n    print(result)\n\nif __name__ == \"__main__\":\n    asyncio.run(test_research_agent())\n</code></pre>"},{"location":"guide/agents/#expected-output","title":"Expected Output","text":"<pre><code>--- [ResearchAgent] Received query: What is the Agent Framework by Microsoft? ---\n[Tool Call] Searching for: Microsoft Agent Framework\n[Tool Call] Reading URL: https://microsoft.com/agent-framework\n--- [ResearchAgent] Responding ---\n\n=== Agent Response ===\nThe Microsoft Agent Framework is a comprehensive platform for building \nenterprise-grade AI agents. It provides advanced orchestration capabilities,\nrobust tool integration, and Azure-native deployment options.\n\nSources:\n- https://microsoft.com/agent-framework\n</code></pre>"},{"location":"guide/agents/#best-practices","title":"Best Practices","text":""},{"location":"guide/agents/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Each agent should have one clear purpose:</p> <p>\u274c Bad: Generic \"do everything\" agent <pre><code>class UniversalAgent:\n    def __init__(self):\n        self.tools = [web_search, read_file, analyze_csv, write_code, ...]\n</code></pre></p> <p>\u2705 Good: Specialized agents <pre><code>class ResearchAgent:  # Web research only\nclass DataAgent:      # Data analysis only\nclass WriterAgent:    # Content generation only\n</code></pre></p>"},{"location":"guide/agents/#2-clear-instructions","title":"2. Clear Instructions","text":"<p>Be explicit about the agent's behavior:</p> <p>\u274c Bad: Vague instructions <pre><code>instructions = \"You are a helpful assistant.\"\n</code></pre></p> <p>\u2705 Good: Detailed instructions <pre><code>instructions = \"\"\"You are a research assistant specializing in academic papers.\n\nProcess:\n1. Search for relevant papers\n2. Read abstracts\n3. Summarize key findings\n4. Cite all sources\n\nNever make up citations or fabricate research.\"\"\"\n</code></pre></p>"},{"location":"guide/agents/#3-resource-management","title":"3. Resource Management","text":"<p>For production use, implement proper resource cleanup:</p> <pre><code>class ResearchAgent:\n    def __init__(self):\n        self._agent_instance = None\n        self._credential = None\n\n    async def _get_agent(self):\n        if self._agent_instance is None:\n            self._credential = AzureCliCredential()\n            client = AzureAIAgentClient(\n                async_credential=self._credential,\n                endpoint=os.getenv(\"AZURE_AI_PROJECT_ENDPOINT\"),\n                deployment_name=os.getenv(\"AZURE_AI_MODEL_DEPLOYMENT_NAME\")\n            )\n            self._agent_instance = ChatAgent(\n                chat_client=client,\n                instructions=self.instructions,\n                tools=self.tools\n            )\n        return self._agent_instance\n\n    async def run(self, query: str) -&gt; str:\n        agent = await self._get_agent()\n        response = await agent.run(query)\n        return response.text\n\n    async def cleanup(self):\n        \"\"\"Clean up resources.\"\"\"\n        if self._credential:\n            await self._credential.close()\n</code></pre>"},{"location":"guide/agents/#4-error-handling","title":"4. Error Handling","text":"<p>Handle failures gracefully:</p> <pre><code>async def run(self, query: str) -&gt; str:\n    try:\n        response = await self._agent.run(query)\n        return response.text\n    except Exception as e:\n        error_msg = f\"Agent error: {str(e)}\"\n        print(error_msg)\n        return f\"I encountered an error: {error_msg}\"\n</code></pre>"},{"location":"guide/agents/#common-issues-troubleshooting","title":"Common Issues &amp; Troubleshooting","text":""},{"location":"guide/agents/#agent-not-using-tools","title":"Agent Not Using Tools","text":"<p>Problem: Agent responds without calling any tools.</p> <p>Solutions: - Make instructions more explicit about when to use tools - Ensure tools are properly registered in <code>self.tools</code> - Check that tool docstrings clearly describe their purpose</p>"},{"location":"guide/agents/#authentication-errors","title":"Authentication Errors","text":"<p>Problem: <code>AzureCliCredential</code> fails.</p> <p>Solutions: <pre><code># Re-authenticate with Azure CLI\naz login\naz account set --subscription &lt;your-subscription-id&gt;\n\n# Verify environment variables\necho $AZURE_AI_PROJECT_ENDPOINT\necho $AZURE_AI_MODEL_DEPLOYMENT_NAME\n</code></pre></p>"},{"location":"guide/agents/#incomplete-responses","title":"Incomplete Responses","text":"<p>Problem: Agent stops mid-response or doesn't finish tasks.</p> <p>Solutions: - Increase token limits if available - Simplify the task or break it into steps - Make instructions more focused</p>"},{"location":"guide/agents/#next-steps","title":"Next Steps","text":"<p>Now that you understand agents, proceed to:</p> <ul> <li>Building Workflows - Orchestrate multiple agents together</li> <li>API Reference - Detailed API documentation</li> <li>Examples - More complex agent patterns</li> </ul>"},{"location":"guide/concepts/","title":"Core Concepts","text":"<p>The Agent Workflow Framework is built on three foundational pillars that work together to enable sophisticated AI agent applications.</p>"},{"location":"guide/concepts/#architecture-overview","title":"Architecture Overview","text":"<p>The framework uses a composition-based architecture that separates concerns into three distinct layers:</p> <ol> <li>Tools Layer: Self-documenting functions that provide capabilities to agents</li> <li>Agents Layer: Specialized AI components that orchestrate tool usage and decision-making</li> <li>Workflows Layer: Graph-based orchestration for coordinating multiple agents</li> </ol>"},{"location":"guide/concepts/#design-philosophy","title":"Design Philosophy","text":""},{"location":"guide/concepts/#composition-over-inheritance","title":"Composition Over Inheritance","text":"<p>Unlike traditional frameworks that require inheriting from base classes, this framework uses composition:</p> <pre><code>class MyAgent:\n    def __init__(self):\n        # Your agent HAS-A ChatAgent (composition)\n        self._agent = ChatAgent(...)\n\n    async def run(self, query: str) -&gt; str:\n        return await self._agent.run(query)\n</code></pre> <p>Benefits: - Cleaner, more maintainable code - Easier testing and mocking - Flexible agent design without framework coupling - Clear separation of business logic from framework internals</p>"},{"location":"guide/concepts/#explicit-over-implicit","title":"Explicit Over Implicit","text":"<p>The framework prioritizes explicitness:</p> <ul> <li>Tools are regular Python functions with clear type annotations</li> <li>Agent instructions are written as plain strings</li> <li>Workflow graphs are built explicitly with <code>.add_edge()</code></li> <li>No hidden magic or auto-discovery mechanisms</li> </ul>"},{"location":"guide/concepts/#azure-first-design","title":"Azure-First Design","text":"<p>Built specifically for Azure AI services:</p> <ul> <li>Native integration with Azure OpenAI</li> <li>Seamless authentication via Azure CLI</li> <li>Environment-based configuration</li> <li>Enterprise-ready security patterns</li> </ul>"},{"location":"guide/concepts/#key-components","title":"Key Components","text":""},{"location":"guide/concepts/#chatagent","title":"ChatAgent","text":"<p>The core AI component that handles LLM interactions:</p> <ul> <li>Manages conversation context and history</li> <li>Executes tool calls and processes results</li> <li>Handles the request/response cycle with the LLM</li> <li>Processes structured outputs and streaming</li> </ul>"},{"location":"guide/concepts/#ai_function-decorator","title":"@ai_function Decorator","text":"<p>Transforms Python functions into AI-callable tools:</p> <ul> <li>Automatically generates JSON schemas for the LLM</li> <li>Uses type annotations and docstrings for schema generation</li> <li>Validates inputs and outputs</li> <li>Provides error handling context to the LLM</li> </ul>"},{"location":"guide/concepts/#workflowbuilder","title":"WorkflowBuilder","text":"<p>Creates directed acyclic graphs (DAGs) for multi-agent orchestration:</p> <ul> <li>Defines data flow between executors</li> <li>Manages state across workflow steps</li> <li>Handles parallel and sequential execution</li> <li>Enables complex multi-agent collaboration patterns</li> </ul>"},{"location":"guide/concepts/#data-flow","title":"Data Flow","text":"<pre><code>User Input\n    \u2193\nWorkflow.run()\n    \u2193\nExecutor 1 \u2192 Agent 1 \u2192 ChatAgent \u2192 LLM\n    \u2193                       \u2193\n    |                   Tool Calls\n    \u2193                       \u2193\nExecutor 2 \u2192 Agent 2 \u2192 ChatAgent \u2192 LLM\n    \u2193\nFinal Output\n</code></pre>"},{"location":"guide/concepts/#prerequisites","title":"Prerequisites","text":"<p>Before using this framework, ensure you have:</p>"},{"location":"guide/concepts/#required-knowledge","title":"Required Knowledge","text":"<ul> <li>Python 3.10+: Intermediate to advanced proficiency</li> <li>Async/await: Understanding of Python's asyncio patterns</li> <li>Type annotations: Familiarity with <code>typing</code> module and <code>Annotated</code></li> <li>Environment variables: Basic knowledge of <code>.env</code> files</li> </ul>"},{"location":"guide/concepts/#azure-setup","title":"Azure Setup","text":"<ul> <li>Active Azure subscription</li> <li>Azure OpenAI resource provisioned</li> <li>Azure CLI installed and authenticated (<code>az login</code>)</li> <li>Required environment variables configured:</li> <li><code>AZURE_AI_PROJECT_ENDPOINT</code></li> <li><code>AZURE_AI_MODEL_DEPLOYMENT_NAME</code></li> </ul>"},{"location":"guide/concepts/#installation","title":"Installation","text":"<p>Complete the Installation &amp; Setup guide before proceeding.</p>"},{"location":"guide/concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the core concepts, proceed to:</p> <ul> <li>Working with Tools - Learn to create AI-callable functions</li> <li>Creating Agents - Build specialized AI agents</li> <li>Building Workflows - Orchestrate multi-agent systems</li> </ul>"},{"location":"guide/tools/","title":"Working with Tools","text":"<p>Tools are the foundation of an agent's capabilities. In this framework, tools are simple Python functions enhanced with the <code>@ai_function</code> decorator.</p>"},{"location":"guide/tools/#what-are-tools","title":"What Are Tools?","text":"<p>Tools are Python functions that agents can call to perform specific tasks:</p> <ul> <li>Web searches: Find information online</li> <li>File operations: Read, write, or process files</li> <li>API calls: Interact with external services</li> <li>Data processing: Transform or analyze data</li> <li>Custom logic: Any Python function you can write</li> </ul>"},{"location":"guide/tools/#creating-your-first-tool","title":"Creating Your First Tool","text":""},{"location":"guide/tools/#basic-structure","title":"Basic Structure","text":"<p>Every tool follows this pattern:</p> <pre><code>from agent_framework import ai_function\nfrom typing import Annotated\nfrom pydantic import Field\n\n@ai_function\ndef tool_name(\n    param: Annotated[type, Field(description=\"Clear description\")]\n) -&gt; return_type:\n    \"\"\"\n    Describe what this tool does and when the agent should use it.\n    \"\"\"\n    # Implementation\n    return result\n</code></pre>"},{"location":"guide/tools/#example-web-search-tool","title":"Example: Web Search Tool","text":"<p>Create a file at <code>src/agent_workflow_framework/tools/web_tools.py</code>:</p> <pre><code>from agent_framework import ai_function\nfrom pydantic import Field\nfrom typing import Annotated\nimport httpx\n\n@ai_function\ndef web_search(\n    query: Annotated[str, Field(description=\"The precise search query for Google.\")]\n) -&gt; str:\n    \"\"\"\n    Performs a web search using the provided query and returns a list of top results.\n    Use this tool when the user asks for current information or facts from the internet.\n    \"\"\"\n    print(f\"[Tool Call] Searching for: {query}\")\n\n    # This is a mock search for demonstration.\n    # In a real app, you would use an actual search API.\n    mock_results = {\n        \"AI framework\": \"Result: Microsoft Agent Framework is a new platform...\",\n        \"python\": \"Result: Python is an interpreted, high-level programming language...\"\n    }\n\n    return mock_results.get(query, f\"No results found for '{query}'.\")\n</code></pre>"},{"location":"guide/tools/#example-url-reader-tool","title":"Example: URL Reader Tool","text":"<pre><code>@ai_function\ndef read_url(\n    url: Annotated[str, Field(description=\"The full URL of the website to read.\")]\n) -&gt; str:\n    \"\"\"\n    Reads the full content from a specific URL and returns it as a string.\n    Use this tool to fetch and read web page content when given a URL.\n    Includes error handling for bad requests.\n    \"\"\"\n    print(f\"[Tool Call] Reading URL: {url}\")\n    try:\n        response = httpx.get(url, follow_redirects=True, timeout=10.0)\n        response.raise_for_status()  # Raise an exception for 4xx or 5xx responses\n        # Return first 1000 chars to avoid oversized context\n        return response.text[:1000] + \"...\"\n    except httpx.RequestError as e:\n        return f\"Error reading URL: {e}\"\n    except httpx.HTTPStatusError as e:\n        return f\"Error: Received status {e.response.status_code} from {e.request.url}\"\n</code></pre>"},{"location":"guide/tools/#how-tools-work","title":"How Tools Work","text":""},{"location":"guide/tools/#schema-generation","title":"Schema Generation","text":"<p>The framework automatically generates a JSON schema for the LLM based on:</p> <ol> <li>Function name: <code>web_search</code> becomes the tool identifier</li> <li>Docstring: Tells the LLM when to use the tool</li> <li>Parameter annotations: <code>Annotated[str, Field(description=\"...\")]</code> describes each parameter</li> <li>Return type: Defines what the tool returns</li> </ol>"},{"location":"guide/tools/#execution-flow","title":"Execution Flow","text":"<pre><code>1. Agent receives user query\n2. LLM decides which tool(s) to call\n3. Framework validates parameters\n4. Tool function executes\n5. Result returns to LLM as context\n6. LLM generates final response\n</code></pre>"},{"location":"guide/tools/#best-practices","title":"Best Practices","text":""},{"location":"guide/tools/#1-descriptions-are-critical","title":"1. Descriptions Are Critical","text":"<p>\u274c Bad: <pre><code>def search(q: str) -&gt; str:\n    \"\"\"Search.\"\"\"\n    pass\n</code></pre></p> <p>\u2705 Good: <pre><code>@ai_function\ndef web_search(\n    query: Annotated[str, Field(description=\"The precise search query including relevant keywords\")]\n) -&gt; str:\n    \"\"\"\n    Performs a web search using the provided query and returns top results.\n    Use this when the user asks for current information or facts.\n    \"\"\"\n    pass\n</code></pre></p> <p>Why: The LLM uses descriptions to decide what data to pass and when to call the tool.</p>"},{"location":"guide/tools/#2-write-clear-docstrings","title":"2. Write Clear Docstrings","text":"<p>The docstring should answer: - What does this tool do? - When should the agent use it? - What kind of results does it return?</p> <p>\u2705 Good example: <pre><code>\"\"\"\nFetches the current stock price for a given ticker symbol.\nUse this tool when the user asks for real-time stock market data.\nReturns the price as a decimal number with currency symbol.\n\"\"\"\n</code></pre></p>"},{"location":"guide/tools/#3-single-responsibility-principle","title":"3. Single Responsibility Principle","text":"<p>Keep tools focused on one task:</p> <p>\u274c Bad: One giant \"research\" tool <pre><code>@ai_function\ndef research(query: str, read_urls: bool, summarize: bool) -&gt; str:\n    # Too many responsibilities\n    pass\n</code></pre></p> <p>\u2705 Good: Separate, focused tools <pre><code>@ai_function\ndef web_search(query: str) -&gt; str:\n    \"\"\"Find relevant URLs.\"\"\"\n    pass\n\n@ai_function\ndef read_url(url: str) -&gt; str:\n    \"\"\"Read content from a URL.\"\"\"\n    pass\n\n@ai_function\ndef summarize_text(text: str) -&gt; str:\n    \"\"\"Summarize long text.\"\"\"\n    pass\n</code></pre></p> <p>Why: This gives the LLM more flexibility and control over the research process.</p>"},{"location":"guide/tools/#4-handle-errors-gracefully","title":"4. Handle Errors Gracefully","text":"<p>Always return descriptive strings on errors:</p> <p>\u274c Bad: <pre><code>@ai_function\ndef read_file(path: str) -&gt; str:\n    return open(path).read()  # Crashes on error\n</code></pre></p> <p>\u2705 Good: <pre><code>@ai_function\ndef read_file(\n    path: Annotated[str, Field(description=\"Full path to the file to read\")]\n) -&gt; str:\n    \"\"\"Reads and returns the contents of a file.\"\"\"\n    try:\n        with open(path, 'r', encoding='utf-8') as f:\n            return f.read()\n    except FileNotFoundError:\n        return f\"Error: File not found at path '{path}'\"\n    except PermissionError:\n        return f\"Error: Permission denied reading file '{path}'\"\n    except Exception as e:\n        return f\"Error reading file: {str(e)}\"\n</code></pre></p> <p>Why: Returning error strings keeps the agent running and gives the LLM context to adapt its strategy.</p>"},{"location":"guide/tools/#5-use-type-annotations","title":"5. Use Type Annotations","text":"<p>Always use <code>Annotated</code> with <code>Field</code>:</p> <pre><code>from typing import Annotated\nfrom pydantic import Field\n\n@ai_function\ndef calculate_distance(\n    lat1: Annotated[float, Field(description=\"Latitude of first location\")],\n    lon1: Annotated[float, Field(description=\"Longitude of first location\")],\n    lat2: Annotated[float, Field(description=\"Latitude of second location\")],\n    lon2: Annotated[float, Field(description=\"Longitude of second location\")]\n) -&gt; float:\n    \"\"\"Calculates distance between two geographic coordinates.\"\"\"\n    pass\n</code></pre>"},{"location":"guide/tools/#common-tool-patterns","title":"Common Tool Patterns","text":""},{"location":"guide/tools/#file-operations","title":"File Operations","text":"<pre><code>@ai_function\ndef write_file(\n    path: Annotated[str, Field(description=\"Full path where file should be written\")],\n    content: Annotated[str, Field(description=\"Content to write to the file\")]\n) -&gt; str:\n    \"\"\"Writes content to a file at the specified path.\"\"\"\n    try:\n        with open(path, 'w', encoding='utf-8') as f:\n            f.write(content)\n        return f\"Successfully wrote {len(content)} characters to {path}\"\n    except Exception as e:\n        return f\"Error writing file: {str(e)}\"\n</code></pre>"},{"location":"guide/tools/#api-calls","title":"API Calls","text":"<pre><code>@ai_function\ndef get_weather(\n    city: Annotated[str, Field(description=\"City name to get weather for\")]\n) -&gt; str:\n    \"\"\"Fetches current weather information for a city.\"\"\"\n    try:\n        response = httpx.get(f\"https://api.weather.com/v1/weather/{city}\")\n        response.raise_for_status()\n        data = response.json()\n        return f\"Temperature: {data['temp']}\u00b0C, Conditions: {data['conditions']}\"\n    except Exception as e:\n        return f\"Error fetching weather: {str(e)}\"\n</code></pre>"},{"location":"guide/tools/#data-processing","title":"Data Processing","text":"<pre><code>@ai_function\ndef analyze_csv(\n    file_path: Annotated[str, Field(description=\"Path to CSV file to analyze\")]\n) -&gt; str:\n    \"\"\"Analyzes a CSV file and returns summary statistics.\"\"\"\n    try:\n        import pandas as pd\n        df = pd.read_csv(file_path)\n        summary = df.describe().to_string()\n        return f\"CSV Analysis:\\n{summary}\"\n    except Exception as e:\n        return f\"Error analyzing CSV: {str(e)}\"\n</code></pre>"},{"location":"guide/tools/#testing-tools","title":"Testing Tools","text":"<p>Test tools independently before using them in agents:</p> <pre><code>import asyncio\n\nasync def test_tool():\n    result = web_search(\"Python programming\")\n    print(result)\n\n    result = read_url(\"https://www.python.org\")\n    print(result[:200])\n\nif __name__ == \"__main__\":\n    asyncio.run(test_tool())\n</code></pre>"},{"location":"guide/tools/#common-issues-troubleshooting","title":"Common Issues &amp; Troubleshooting","text":""},{"location":"guide/tools/#tool-not-being-called","title":"Tool Not Being Called","text":"<p>Problem: Agent doesn't use your tool even though it should.</p> <p>Solutions: - Improve the docstring to be more explicit about when to use the tool - Add more specific keywords to parameter descriptions - Ensure the tool name clearly indicates its purpose</p>"},{"location":"guide/tools/#invalid-parameters","title":"Invalid Parameters","text":"<p>Problem: LLM passes wrong data types or missing parameters.</p> <p>Solutions: - Make descriptions more specific about expected format - Add examples in the docstring - Validate and return helpful error messages</p>"},{"location":"guide/tools/#tool-execution-fails","title":"Tool Execution Fails","text":"<p>Problem: Tool crashes during execution.</p> <p>Solutions: - Add comprehensive error handling with try/except - Return descriptive error strings instead of raising exceptions - Log errors for debugging while returning user-friendly messages</p>"},{"location":"guide/tools/#next-steps","title":"Next Steps","text":"<p>Now that you understand tools, proceed to:</p> <ul> <li>Creating Agents - Learn how to build agents that use these tools</li> <li>Building Workflows - Orchestrate multiple agents with different tools</li> </ul>"},{"location":"guide/workflows/","title":"Building Workflows","text":"<p>Workflows enable multi-agent orchestration by defining how agents collaborate. The <code>WorkflowBuilder</code> creates directed acyclic graphs (DAGs) where data flows from one executor to the next.</p>"},{"location":"guide/workflows/#what-are-workflows","title":"What Are Workflows?","text":"<p>A workflow is a graph of executors where:</p> <ul> <li>Nodes (Executors): Functions that wrap agent calls or other logic</li> <li>Edges: Define data flow from one executor to another</li> <li>Start Executor: The entry point of the workflow</li> <li>Output: The final result from the last executor</li> </ul> <pre><code>User Input \u2192 Executor 1 \u2192 Executor 2 \u2192 Executor 3 \u2192 Final Output\n                \u2193            \u2193            \u2193\n             Agent 1      Agent 2      Agent 3\n</code></pre>"},{"location":"guide/workflows/#creating-your-first-workflow","title":"Creating Your First Workflow","text":""},{"location":"guide/workflows/#basic-structure","title":"Basic Structure","text":"<p>Every workflow follows this pattern:</p> <pre><code>from agent_framework import WorkflowBuilder, WorkflowContext, executor\nfrom typing import Annotated\nfrom pydantic import Field\n\n# 1. Define executors (workflow nodes)\n@executor(id=\"step1\")\nasync def first_step(\n    input_data: Annotated[str, Field(description=\"Input description\")]\n) -&gt; dict:\n    \"\"\"First step logic.\"\"\"\n    result = await agent1.run(input_data)\n    return {\"data\": result}\n\n@executor(id=\"step2\")\nasync def second_step(\n    input_data: Annotated[dict, Field(description=\"Output from step1\")]\n) -&gt; str:\n    \"\"\"Second step logic.\"\"\"\n    result = await agent2.run(input_data[\"data\"])\n    return result\n\n# 2. Build the workflow\nworkflow = (WorkflowBuilder()\n    .add_edge(first_step, second_step)  # Define data flow\n    .set_start_executor(first_step)      # Set entry point\n    .build())                            # Compile\n\n# 3. Run the workflow\nresult = await workflow.run(\"initial input\")\n</code></pre>"},{"location":"guide/workflows/#complete-example-research-writing-workflow","title":"Complete Example: Research + Writing Workflow","text":"<p>Let's create a workflow where: 1. ResearchAgent gathers information about a topic 2. WriterAgent uses that information to write a blog post</p> <p>Create <code>run_workflow.py</code>:</p> <pre><code>import asyncio\nimport os\nfrom dotenv import load_dotenv\nfrom agent_framework import WorkflowBuilder, WorkflowContext, executor\nfrom pydantic import Field\nfrom typing import Annotated\n\n# Import our agents\nfrom agents import ResearchAgent, WriterAgent\n\n# --- 1. Instantiate Agents ---\n# Create global instances for the workflow to use.\n# This ensures they are initialized once.\nprint(\"Initializing agents...\")\ntry:\n    research_agent = ResearchAgent()\n    writer_agent = WriterAgent()\nexcept Exception as e:\n    print(f\"Error initializing agents. Is your .env file set up? Error: {e}\")\n    exit()\n\n# --- 2. Define Workflow Executors ---\n# Executors are the \"nodes\" in our workflow graph.\n# They are async functions that call our agents.\n\n@executor(id=\"run_research\")\nasync def research_executor(\n    topic: Annotated[str, Field(description=\"The topic to research\")]\n) -&gt; dict:\n    \"\"\"\n    First step: Run the ResearchAgent to gather information.\n    This executor's output (a dict) will be the input for the next step.\n    \"\"\"\n    print(f\"--- [Executor: run_research] START ---\")\n    research_notes = await research_agent.run(f\"Find information on: {topic}\")\n    return {\"topic\": topic, \"research_notes\": research_notes}\n\n@executor(id=\"run_writing\")\nasync def writing_executor(\n    inputs: Annotated[dict, Field(description=\"The research notes from the previous step\")]\n) -&gt; str:\n    \"\"\"\n    Second step: Run the WriterAgent to write the blog post.\n    It takes the dictionary from `research_executor` as its input.\n    \"\"\"\n    print(f\"--- [Executor: run_writing] START ---\")\n    topic = inputs[\"topic\"]\n    research_notes = inputs[\"research_notes\"]\n\n    blog_post = await writer_agent.run(topic, research_notes)\n    return blog_post  # This is the final output of the workflow\n\n# --- 3. Build the Workflow ---\n\nprint(\"Building workflow...\")\nworkflow = (WorkflowBuilder()\n    # Define the data flow: output of `research_executor`\n    # goes to the input of `writing_executor`.\n    .add_edge(research_executor, writing_executor)\n\n    # Define the entry point of the workflow\n    .set_start_executor(research_executor)\n\n    # Compile the workflow\n    .build())\n\n# --- 4. Run the Workflow ---\n\nasync def main():\n    print(\"--- Starting Workflow ---\")\n    load_dotenv()  # Load the .env file\n\n    initial_topic = \"the future of AI in 2025\"\n\n    # The .run() method takes the input for the start_executor\n    final_result = await workflow.run(initial_topic)\n\n    print(\"\\n--- Workflow Complete ---\")\n    print(\"Final Blog Post:\")\n    print(\"=======================\")\n    print(final_result)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/workflows/#understanding-executors","title":"Understanding Executors","text":""},{"location":"guide/workflows/#what-is-an-executor","title":"What Is an Executor?","text":"<p>An executor is a decorated async function that represents one step in your workflow:</p> <pre><code>@executor(id=\"unique_step_id\")\nasync def my_executor(\n    input_param: Annotated[type, Field(description=\"What this input is\")]\n) -&gt; output_type:\n    \"\"\"\n    Description of what this step does.\n    \"\"\"\n    # Call agents, process data, make decisions\n    result = await some_agent.run(input_param)\n    return result\n</code></pre> <p>Key points: - Must be decorated with <code>@executor(id=\"unique_id\")</code> - Must be an <code>async</code> function - Must use <code>Annotated[type, Field(description=\"...\")]</code> for parameters - Return value is passed to the next executor</p>"},{"location":"guide/workflows/#executor-patterns","title":"Executor Patterns","text":""},{"location":"guide/workflows/#1-agent-wrapper-pattern","title":"1. Agent Wrapper Pattern","text":"<pre><code>@executor(id=\"analyze\")\nasync def analysis_executor(\n    data: Annotated[str, Field(description=\"Data to analyze\")]\n) -&gt; dict:\n    \"\"\"Wraps a data analyst agent.\"\"\"\n    result = await data_analyst_agent.run(data)\n    return {\"analysis\": result, \"timestamp\": datetime.now().isoformat()}\n</code></pre>"},{"location":"guide/workflows/#2-data-transformation-pattern","title":"2. Data Transformation Pattern","text":"<pre><code>@executor(id=\"transform\")\nasync def transform_executor(\n    raw_data: Annotated[dict, Field(description=\"Raw data from previous step\")]\n) -&gt; str:\n    \"\"\"Transforms data without calling an agent.\"\"\"\n    # Pure Python logic\n    processed = raw_data[\"analysis\"].upper()\n    return processed\n</code></pre>"},{"location":"guide/workflows/#3-conditional-logic-pattern","title":"3. Conditional Logic Pattern","text":"<pre><code>@executor(id=\"decide\")\nasync def decision_executor(\n    input_data: Annotated[dict, Field(description=\"Data to evaluate\")]\n) -&gt; str:\n    \"\"\"Makes decisions based on data.\"\"\"\n    if input_data[\"confidence\"] &gt; 0.8:\n        return await high_confidence_agent.run(input_data[\"text\"])\n    else:\n        return await verification_agent.run(input_data[\"text\"])\n</code></pre>"},{"location":"guide/workflows/#building-complex-workflows","title":"Building Complex Workflows","text":""},{"location":"guide/workflows/#multiple-edges-sequential-chain","title":"Multiple Edges (Sequential Chain)","text":"<p>Create a linear pipeline:</p> <pre><code>workflow = (WorkflowBuilder()\n    .add_edge(step1, step2)\n    .add_edge(step2, step3)\n    .add_edge(step3, step4)\n    .set_start_executor(step1)\n    .build())\n</code></pre> <p>Data flows: <code>step1 \u2192 step2 \u2192 step3 \u2192 step4</code></p>"},{"location":"guide/workflows/#parallel-execution","title":"Parallel Execution","text":"<p>Note: The current framework executes sequentially based on edges. For true parallel execution, you'll need to manage that within a single executor:</p> <pre><code>@executor(id=\"parallel_step\")\nasync def parallel_executor(\n    input_data: Annotated[str, Field(description=\"Input for multiple agents\")]\n) -&gt; dict:\n    \"\"\"Calls multiple agents in parallel.\"\"\"\n    # Run multiple agents concurrently\n    results = await asyncio.gather(\n        agent1.run(input_data),\n        agent2.run(input_data),\n        agent3.run(input_data)\n    )\n\n    return {\n        \"agent1_result\": results[0],\n        \"agent2_result\": results[1],\n        \"agent3_result\": results[2]\n    }\n</code></pre>"},{"location":"guide/workflows/#branching-logic","title":"Branching Logic","text":"<pre><code>@executor(id=\"branch\")\nasync def branching_executor(\n    input_data: Annotated[str, Field(description=\"Input to evaluate\")]\n) -&gt; str:\n    \"\"\"Routes to different agents based on input.\"\"\"\n    if \"technical\" in input_data.lower():\n        return await technical_agent.run(input_data)\n    elif \"creative\" in input_data.lower():\n        return await creative_agent.run(input_data)\n    else:\n        return await general_agent.run(input_data)\n</code></pre>"},{"location":"guide/workflows/#data-flow-between-executors","title":"Data Flow Between Executors","text":""},{"location":"guide/workflows/#how-data-passes-through-edges","title":"How Data Passes Through Edges","text":"<p>When you define <code>.add_edge(executor_a, executor_b)</code>:</p> <ol> <li><code>executor_a</code> returns a value</li> <li>That value becomes the first parameter of <code>executor_b</code></li> <li>The type must match the parameter annotation</li> </ol> <p>Example:</p> <pre><code>@executor(id=\"step1\")\nasync def first_step(query: str) -&gt; dict:\n    return {\"result\": \"processed\", \"count\": 42}\n\n@executor(id=\"step2\")\nasync def second_step(\n    data: Annotated[dict, Field(description=\"Output from step1\")]\n) -&gt; str:\n    # `data` receives {\"result\": \"processed\", \"count\": 42}\n    return f\"Got {data['count']} results: {data['result']}\"\n</code></pre>"},{"location":"guide/workflows/#multiple-edges-from-one-executor","title":"Multiple Edges from One Executor","text":"<p>You can send one executor's output to multiple downstream executors:</p> <pre><code>@executor(id=\"source\")\nasync def source_executor(input: str) -&gt; dict:\n    return {\"data\": input}\n\n@executor(id=\"process_a\")\nasync def process_a_executor(data: dict) -&gt; str:\n    return f\"Process A: {data['data']}\"\n\n@executor(id=\"process_b\")\nasync def process_b_executor(data: dict) -&gt; str:\n    return f\"Process B: {data['data']}\"\n\n# Both process_a and process_b receive the same output from source\nworkflow = (WorkflowBuilder()\n    .add_edge(source_executor, process_a_executor)\n    .add_edge(source_executor, process_b_executor)\n    .set_start_executor(source_executor)\n    .build())\n</code></pre> <p>Note: Currently, this creates a fork where both execute with the same input. The workflow will complete when all branches finish.</p>"},{"location":"guide/workflows/#using-workflowcontext","title":"Using WorkflowContext","text":"<p>For advanced state management, use <code>WorkflowContext</code>:</p> <pre><code>@executor(id=\"stateful_step\")\nasync def stateful_executor(\n    input_data: Annotated[str, Field(description=\"Input data\")],\n    ctx: WorkflowContext[str]  # Access workflow context\n) -&gt; str:\n    \"\"\"Executor with access to workflow context.\"\"\"\n    # Send messages to other parts of the workflow\n    await ctx.send_message(\"Progress update\")\n\n    # Yield intermediate outputs\n    await ctx.yield_output(\"Intermediate result\")\n\n    # Final return\n    return \"Final result\"\n</code></pre>"},{"location":"guide/workflows/#testing-workflows","title":"Testing Workflows","text":""},{"location":"guide/workflows/#test-individual-executors-first","title":"Test Individual Executors First","text":"<pre><code>async def test_research_executor():\n    result = await research_executor(\"AI trends 2025\")\n    assert \"research_notes\" in result\n    assert \"topic\" in result\n    print(f\"\u2713 Research executor works: {result}\")\n\nasync def test_writing_executor():\n    mock_input = {\n        \"topic\": \"Test Topic\",\n        \"research_notes\": \"Test notes about the topic.\"\n    }\n    result = await writing_executor(mock_input)\n    assert len(result) &gt; 0\n    print(f\"\u2713 Writing executor works: {len(result)} chars\")\n\n# Run tests\nasyncio.run(test_research_executor())\nasyncio.run(test_writing_executor())\n</code></pre>"},{"location":"guide/workflows/#test-the-complete-workflow","title":"Test the Complete Workflow","text":"<pre><code>async def test_workflow():\n    load_dotenv()\n\n    # Test with known input\n    result = await workflow.run(\"Python programming\")\n\n    # Validate output\n    assert len(result) &gt; 100\n    assert \"Python\" in result\n    print(\"\u2713 Workflow test passed\")\n\nasyncio.run(test_workflow())\n</code></pre>"},{"location":"guide/workflows/#expected-output","title":"Expected Output","text":"<p>When running the complete example:</p> <pre><code>Initializing agents...\nBuilding workflow...\n--- Starting Workflow ---\n--- [Executor: run_research] START ---\n\n--- [ResearchAgent] Received query: Find information on: the future of AI in 2025 ---\n[Tool Call] Searching for: AI trends 2025\n[Tool Call] Reading URL: https://example.com/ai-2025\n--- [ResearchAgent] Responding ---\n--- [Executor: run_writing] START ---\n\n--- [WriterAgent] Received prompt ---\n--- [WriterAgent] Responding ---\n\n--- Workflow Complete ---\nFinal Blog Post:\n=======================\n## The Future of AI in 2025\n\nThe artificial intelligence landscape in 2025 is poised for transformative \nbreakthroughs. Enterprise adoption of AI agents will accelerate...\n\n[Blog post continues...]\n</code></pre>"},{"location":"guide/workflows/#best-practices","title":"Best Practices","text":""},{"location":"guide/workflows/#1-keep-executors-focused","title":"1. Keep Executors Focused","text":"<p>\u274c Bad: One executor doing everything <pre><code>@executor(id=\"do_everything\")\nasync def everything_executor(input: str) -&gt; str:\n    research = await research_agent.run(input)\n    analysis = await analysis_agent.run(research)\n    writing = await writer_agent.run(analysis)\n    return writing\n</code></pre></p> <p>\u2705 Good: Separate executors for each step <pre><code>@executor(id=\"research\")\nasync def research_exec(input: str) -&gt; str: ...\n\n@executor(id=\"analyze\")\nasync def analyze_exec(research: str) -&gt; str: ...\n\n@executor(id=\"write\")\nasync def write_exec(analysis: str) -&gt; str: ...\n</code></pre></p>"},{"location":"guide/workflows/#2-use-type-hints-and-descriptions","title":"2. Use Type Hints and Descriptions","text":"<p>Always annotate parameters clearly:</p> <pre><code>@executor(id=\"process\")\nasync def process_executor(\n    # \u2705 Good: Clear type and description\n    data: Annotated[dict, Field(description=\"Dictionary containing 'text' and 'metadata' keys\")]\n) -&gt; str:\n    ...\n</code></pre>"},{"location":"guide/workflows/#3-handle-errors-in-executors","title":"3. Handle Errors in Executors","text":"<pre><code>@executor(id=\"safe_step\")\nasync def safe_executor(\n    input_data: Annotated[str, Field(description=\"Input to process\")]\n) -&gt; str:\n    try:\n        result = await agent.run(input_data)\n        return result\n    except Exception as e:\n        print(f\"Error in executor: {e}\")\n        return f\"Error occurred: {str(e)}\"\n</code></pre>"},{"location":"guide/workflows/#4-log-execution-flow","title":"4. Log Execution Flow","text":"<p>Add logging to track workflow progress:</p> <pre><code>@executor(id=\"logged_step\")\nasync def logged_executor(\n    input_data: Annotated[str, Field(description=\"Input\")]\n) -&gt; str:\n    print(f\"[{datetime.now()}] Starting logged_step with input: {input_data[:50]}\")\n    result = await agent.run(input_data)\n    print(f\"[{datetime.now()}] Completed logged_step: {len(result)} chars\")\n    return result\n</code></pre>"},{"location":"guide/workflows/#common-issues-troubleshooting","title":"Common Issues &amp; Troubleshooting","text":""},{"location":"guide/workflows/#workflow-doesnt-start","title":"Workflow Doesn't Start","text":"<p>Problem: Workflow hangs or doesn't execute.</p> <p>Solutions: - Ensure <code>.set_start_executor()</code> is called - Verify the start executor is included in an edge - Check that <code>.build()</code> is called before <code>.run()</code></p>"},{"location":"guide/workflows/#data-type-mismatches","title":"Data Type Mismatches","text":"<p>Problem: \"Type mismatch\" or \"unexpected parameter\" errors.</p> <p>Solutions: - Ensure return type of executor A matches parameter type of executor B - Use <code>dict</code> for complex data passing - Verify <code>Annotated</code> types are correct</p>"},{"location":"guide/workflows/#executors-not-chaining","title":"Executors Not Chaining","text":"<p>Problem: Only first executor runs, rest are skipped.</p> <p>Solutions: - Check that edges are defined correctly - Ensure return values are not <code>None</code> - Verify executor IDs are unique</p>"},{"location":"guide/workflows/#workflow-times-out","title":"Workflow Times Out","text":"<p>Problem: Workflow runs but never completes.</p> <p>Solutions: - Check for infinite loops in executor logic - Ensure all async calls use <code>await</code> - Verify agents complete and return values</p>"},{"location":"guide/workflows/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guide/workflows/#retry-logic","title":"Retry Logic","text":"<pre><code>@executor(id=\"retry_step\")\nasync def retry_executor(\n    input_data: Annotated[str, Field(description=\"Input\")]\n) -&gt; str:\n    max_retries = 3\n    for attempt in range(max_retries):\n        try:\n            result = await agent.run(input_data)\n            return result\n        except Exception as e:\n            if attempt == max_retries - 1:\n                return f\"Failed after {max_retries} attempts: {e}\"\n            print(f\"Attempt {attempt + 1} failed, retrying...\")\n            await asyncio.sleep(2 ** attempt)  # Exponential backoff\n</code></pre>"},{"location":"guide/workflows/#caching-results","title":"Caching Results","text":"<pre><code>_cache = {}\n\n@executor(id=\"cached_step\")\nasync def cached_executor(\n    input_data: Annotated[str, Field(description=\"Input\")]\n) -&gt; str:\n    if input_data in _cache:\n        print(\"Returning cached result\")\n        return _cache[input_data]\n\n    result = await expensive_agent.run(input_data)\n    _cache[input_data] = result\n    return result\n</code></pre>"},{"location":"guide/workflows/#next-steps","title":"Next Steps","text":"<p>Now that you understand workflows, explore:</p> <ul> <li>API Reference - Detailed API documentation</li> <li>Examples - Complex workflow patterns</li> <li>Core Concepts - Deeper understanding of the framework architecture</li> </ul>"}]}